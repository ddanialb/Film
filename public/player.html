<!DOCTYPE html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÙÛŒÙ„Ù… Ø¨ÛŒÙ†Ø§ - Ù¾Ø®Ø´ Ø¢Ù†Ù„Ø§ÛŒÙ†</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --primary: #6366f1;
        --secondary: #8b5cf6;
        --bg: #0a0a0f;
        --card: rgba(20, 20, 30, 0.9);
        --border: rgba(255, 255, 255, 0.08);
        --text: #f1f1f1;
        --muted: #888;
      }
      @font-face {
        font-family: "ShabnamLightFD";
        src: url("/fonts/Shabnam-Light-FD.woff2") format("woff2"),
          url("/fonts/Shabnam-Light-FD.woff") format("woff");
        font-weight: 300;
        font-display: swap;
      }
      body {
        font-family: "ShabnamLightFD", system-ui, sans-serif;
        background: var(--bg);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        padding: 15px;
      }
      .container {
        background: var(--card);
        padding: 25px;
        border-radius: 20px;
        width: 100%;
        max-width: 950px;
        border: 1px solid var(--border);
      }
      .header {
        text-align: center;
        margin-bottom: 20px;
      }
      .logo {
        width: 50px;
        height: 50px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        border-radius: 14px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        margin-bottom: 10px;
      }
      h1 { color: var(--text); font-size: 22px; }
      .subtitle { margin-top: 5px; font-size: 12px; color: var(--muted); }
      .nav-row {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 12px;
        flex-wrap: wrap;
      }
      .nav-btn {
        padding: 8px 18px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--border);
        border-radius: 20px;
        color: var(--text);
        text-decoration: none;
        font-size: 13px;
        transition: all 0.2s;
      }
      .nav-btn:hover { background: rgba(255,255,255,0.15); }
      .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-direction: row-reverse;
      }
      input {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.3);
        color: var(--text);
        font-size: 14px;
        outline: none;
        direction: ltr;
        text-align: left;
      }
      input:focus { border-color: var(--primary); }
      .btn {
        padding: 12px 25px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: #fff;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
      }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .loader { display: none; justify-content: center; padding: 25px; }
      .loader.show { display: flex; }
      .spinner {
        width: 35px;
        height: 35px;
        border: 3px solid var(--border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin { to { transform: rotate(360deg); } }
      .video-container {
        display: none;
        border-radius: 14px;
        overflow: hidden;
        background: #000;
        margin-bottom: 15px;
        position: relative;
      }
      .video-container.show { display: block; }
      video { width: 100%; display: block; }
      
      /* Custom subtitle overlay */
      .subtitle-overlay {
        position: absolute;
        bottom: 80px;
        left: 0;
        right: 0;
        text-align: center;
        pointer-events: none;
        z-index: 10;
        padding: 0 20px;
      }
      .subtitle-text {
        display: inline-block;
        padding: 8px 16px;
        border-radius: 6px;
        max-width: 90%;
        white-space: pre-wrap;
        direction: auto;
        unicode-bidi: plaintext;
        font-size: 20px;
        color: #fff;
        background: rgba(0,0,0,0.8);
        text-shadow: 1px 1px 2px #000;
      }
      .subtitle-text:empty { display: none; }
      .status {
        text-align: center;
        font-size: 13px;
        padding: 8px;
        border-radius: 8px;
        margin-bottom: 15px;
      }
      .status:empty { display: none; }
      .status.error { background: rgba(239, 68, 68, 0.1); color: #f87171; }
      .status.success { background: rgba(34, 197, 94, 0.1); color: #4ade80; }
      .status.loading { background: rgba(234, 179, 8, 0.1); color: #facc15; }
      
      /* Selection UI */
      .selection-area {
        background: rgba(0,0,0,0.2);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
      }
      .step-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .step-num {
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, #feca57, #ff9f43);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        color: #000;
      }
      .step-title { color: #feca57; font-size: 14px; font-weight: bold; }
      .back-link {
        margin-right: auto;
        color: var(--muted);
        font-size: 12px;
        cursor: pointer;
        text-decoration: underline;
      }
      .back-link:hover { color: var(--text); }
      
      /* Type buttons */
      .type-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
      }
      .type-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        background: linear-gradient(135deg, rgba(99,102,241,0.12), rgba(139,92,246,0.12));
        border: 2px solid rgba(99,102,241,0.25);
        border-radius: 12px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      }
      .type-card:hover {
        background: linear-gradient(135deg, rgba(99,102,241,0.25), rgba(139,92,246,0.25));
        border-color: rgba(99,102,241,0.5);
        transform: translateY(-2px);
      }
      .type-card .icon { font-size: 1.8rem; }
      .type-card .info { flex: 1; }
      .type-card .label { font-weight: bold; font-size: 14px; }
      .type-card .meta { font-size: 11px; color: var(--muted); margin-top: 3px; }
      
      /* Quality buttons */
      .quality-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 10px;
      }
      .quality-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        padding: 16px 12px;
        background: linear-gradient(135deg, rgba(162,155,254,0.12), rgba(129,140,248,0.12));
        border: 2px solid rgba(162,155,254,0.25);
        border-radius: 12px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      }
      .quality-card:hover {
        background: linear-gradient(135deg, rgba(162,155,254,0.25), rgba(129,140,248,0.25));
        border-color: rgba(162,155,254,0.5);
        transform: translateY(-2px);
      }
      .quality-card .q-name { font-weight: bold; font-size: 13px; color: #a29bfe; }
      .quality-card .q-meta { font-size: 11px; color: var(--muted); }
      .quality-card .q-size { font-size: 10px; color: #2ecc71; background: rgba(46,204,113,0.15); padding: 2px 8px; border-radius: 8px; }
      
      /* Episode buttons */
      .episode-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .ep-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        padding: 10px 14px;
        background: rgba(255,255,255,0.05);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 70px;
      }
      .ep-card:hover {
        background: rgba(99,102,241,0.2);
        border-color: rgba(99,102,241,0.4);
      }
      .ep-card.active {
        background: linear-gradient(135deg, rgba(99,102,241,0.3), rgba(139,92,246,0.3));
        border-color: var(--primary);
        box-shadow: 0 0 15px rgba(99,102,241,0.3);
      }
      .ep-card .ep-num { font-weight: bold; font-size: 13px; color: var(--primary); }
      .ep-card .ep-size { font-size: 10px; color: var(--muted); }
      
      /* Current selection display */
      .current-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .sel-tag {
        padding: 5px 12px;
        background: rgba(254,202,87,0.15);
        border: 1px solid rgba(254,202,87,0.3);
        border-radius: 20px;
        font-size: 12px;
        color: #feca57;
      }
      
      /* Subtitle UI */
      .subtitle-section {
        background: rgba(0,0,0,0.3);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
      }
      .subtitle-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        cursor: pointer;
      }
      .subtitle-header .icon { font-size: 20px; }
      .subtitle-header .title { color: #feca57; font-weight: bold; font-size: 14px; }
      .subtitle-header .toggle { margin-right: auto; color: var(--muted); font-size: 12px; }
      .subtitle-content { display: none; }
      .subtitle-content.show { display: block; }
      
      .sub-search-row {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
      }
      .sub-search-row input {
        flex: 1;
        padding: 10px 14px;
        font-size: 13px;
      }
      .sub-search-row .btn {
        padding: 10px 18px;
        font-size: 13px;
      }
      
      .lang-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .lang-btn {
        padding: 8px 14px;
        background: rgba(99,102,241,0.15);
        border: 1px solid rgba(99,102,241,0.3);
        border-radius: 20px;
        color: #a5b4fc;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .lang-btn:hover, .lang-btn.active {
        background: rgba(99,102,241,0.3);
        border-color: var(--primary);
        color: #fff;
      }
      .lang-btn .count {
        background: rgba(0,0,0,0.3);
        padding: 2px 6px;
        border-radius: 10px;
        margin-right: 5px;
        font-size: 10px;
      }
      
      .sub-list {
        max-height: 300px;
        overflow-y: auto;
        padding-left: 8px;
      }
      .sub-list::-webkit-scrollbar {
        width: 6px;
      }
      .sub-list::-webkit-scrollbar-track {
        background: rgba(255,255,255,0.05);
        border-radius: 3px;
      }
      .sub-list::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.3);
        border-radius: 3px;
      }
      .sub-list::-webkit-scrollbar-thumb:hover {
        background: rgba(255,255,255,0.5);
      }
      .sub-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px;
        background: rgba(255,255,255,0.03);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .sub-item:hover {
        background: rgba(99,102,241,0.1);
        border-color: rgba(99,102,241,0.3);
      }
      .sub-item .rating {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-top: 6px;
        flex-shrink: 0;
      }
      .sub-item .rating.good { background: #4ade80; }
      .sub-item .rating.neutral, .sub-item .rating.not { background: #fbbf24; }
      .sub-item .info { flex: 1; min-width: 0; }
      .sub-item .releases {
        font-size: 12px;
        color: var(--text);
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .sub-item .meta {
        font-size: 11px;
        color: var(--muted);
      }
      .sub-item .author { color: #a78bfa; }
      
      .file-picker {
        background: rgba(0,0,0,0.2);
        border-radius: 10px;
        padding: 12px;
        margin-top: 10px;
      }
      .file-picker-title {
        font-size: 13px;
        color: #feca57;
        margin-bottom: 10px;
      }
      .file-btn {
        display: block;
        width: 100%;
        padding: 10px 14px;
        background: rgba(46,204,113,0.1);
        border: 1px solid rgba(46,204,113,0.3);
        border-radius: 8px;
        color: #4ade80;
        font-size: 12px;
        text-align: right;
        cursor: pointer;
        margin-bottom: 6px;
        transition: all 0.2s;
      }
      .file-btn:hover {
        background: rgba(46,204,113,0.2);
        border-color: rgba(46,204,113,0.5);
      }
      .file-btn.active {
        background: rgba(46,204,113,0.3);
        border-color: #4ade80;
      }
      
      .sub-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--border);
      }
      .sub-control-btn {
        padding: 6px 12px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 11px;
        cursor: pointer;
      }
      .sub-control-btn:hover { background: rgba(255,255,255,0.15); }
      .sub-control-btn.active { background: rgba(99,102,241,0.3); border-color: var(--primary); }
      
      .sub-settings {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-top: 12px;
        padding: 14px;
        background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(139,92,246,0.1));
        border: 1px solid rgba(99,102,241,0.2);
        border-radius: 10px;
      }
      .sub-settings-bar {
        background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.15));
        border: 1px solid rgba(99,102,241,0.3);
        border-radius: 12px;
        padding: 12px 15px;
        margin-bottom: 15px;
      }
      .sub-settings-bar .sub-settings-title {
        font-size: 13px;
        font-weight: bold;
        color: #a5b4fc;
        margin-bottom: 10px;
      }
      .sub-settings-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      .sub-settings-grid .sub-setting {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        font-size: 12px;
      }
      .sub-settings-grid .sub-setting label {
        color: var(--muted);
        font-size: 11px;
      }
      .sub-settings-grid select {
        padding: 4px 8px;
        background: rgba(0,0,0,0.4);
        border: 1px solid var(--border);
        border-radius: 5px;
        color: var(--text);
        font-size: 11px;
      }
      .sub-settings-grid input[type="range"] {
        width: 60px;
        accent-color: var(--primary);
      }
      .sub-settings-grid input[type="color"] {
        width: 28px;
        height: 24px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .sub-settings-grid #subSizeVal {
        color: #a5b4fc;
        font-size: 11px;
        min-width: 35px;
      }
      .sub-settings-grid #delayVal {
        color: #feca57;
        font-size: 11px;
        min-width: 30px;
        text-align: center;
      }
      .delay-btn {
        width: 24px;
        height: 24px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.3);
        color: var(--text);
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }
      .delay-btn:hover { background: rgba(99,102,241,0.3); }
      .sub-remove-btn {
        padding: 6px 12px;
        background: rgba(239,68,68,0.2);
        border: 1px solid rgba(239,68,68,0.3);
        color: #f87171;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }
      .sub-remove-btn:hover { background: rgba(239,68,68,0.4); }
      .sub-setting {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: rgba(0,0,0,0.2);
        border-radius: 8px;
      }
      .sub-setting label {
        font-size: 12px;
        color: var(--text);
        min-width: 50px;
      }
      .sub-setting input[type="range"] {
        flex: 1;
        min-width: 60px;
        padding: 0;
        accent-color: var(--primary);
      }
      .sub-setting input[type="color"] {
        width: 32px;
        height: 28px;
        padding: 0;
        border: 2px solid var(--border);
        border-radius: 6px;
        cursor: pointer;
        background: transparent;
      }
      .sub-setting select {
        flex: 1;
        padding: 6px 10px;
        background: rgba(0,0,0,0.4);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 12px;
      }
      
      .sub-status {
        font-size: 12px;
        padding: 8px;
        border-radius: 6px;
        margin-top: 10px;
        text-align: center;
      }
      .sub-status:empty { display: none; }
      .sub-status.loading { background: rgba(234,179,8,0.1); color: #facc15; }
      .sub-status.success { background: rgba(34,197,94,0.1); color: #4ade80; }
      .sub-status.error { background: rgba(239,68,68,0.1); color: #f87171; }
      
      .footer {
        margin-top: 20px;
        text-align: center;
        padding-top: 15px;
        border-top: 1px solid var(--border);
      }
      .credit {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: var(--text);
        font-size: 13px;
      }
      .credit-name {
        background: linear-gradient(135deg, #a78bfa, #60a5fa);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 700;
      }
      @media (max-width: 600px) {
        .container { padding: 15px; }
        .input-group { flex-direction: column; }
        .btn { width: 100%; }
        .type-grid { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header class="header">
        <div class="logo">â–¶ï¸</div>
        <h1>ÙÛŒÙ„Ù… Ø¨ÛŒÙ†Ø§</h1>
        <p class="subtitle">Ù¾Ø®Ø´ Ø¢Ù†Ù„Ø§ÛŒÙ† ÙÛŒÙ„Ù… Ùˆ Ø³Ø±ÛŒØ§Ù„</p>
        <div class="nav-row">
          <a href="/" class="nav-btn">ğŸ¬ ÙÛŒÙ„Ù… ÙØ§Ø±Ø³ÛŒ</a>
          <a href="/telegram.html" class="nav-btn">ğŸŒ ÙÛŒÙ„Ù… Ø®Ø§Ø±Ø¬ÛŒ</a>
          <a href="#" id="backToMovie" class="nav-btn" style="display:none;">â† Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ ÙÛŒÙ„Ù…</a>
        </div>
      </header>

      <div class="input-group">
        <input type="text" id="url" placeholder="Ù„ÛŒÙ†Ú© ÙˆÛŒØ¯ÛŒÙˆ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯..." />
        <button class="btn" id="btn">â–¶ Ù¾Ø®Ø´</button>
      </div>

      <div class="loader" id="loader"><div class="spinner"></div></div>
      <div class="video-container" id="player">
        <video id="video" controls playsinline></video>
        <div class="subtitle-overlay" id="subtitleOverlay">
          <span class="subtitle-text" id="subtitleText"></span>
        </div>
      </div>
      <div class="status" id="status"></div>

      <div class="sub-settings-bar" id="subSettingsBar" style="display:none;">
        <div class="sub-settings-title">âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø²ÛŒØ±Ù†ÙˆÛŒØ³</div>
        <div class="sub-settings-grid">
          <div class="sub-setting">
            <label>âœï¸ ÙÙˆÙ†Øª:</label>
            <select id="subFont" onchange="updateSubStyle()">
              <option value="ShabnamLightFD, Tahoma">Ø´Ø¨Ù†Ù…</option>
              <option value="Tahoma, Arial">ØªØ§Ù‡ÙˆÙ…Ø§</option>
              <option value="Arial, sans-serif">Arial</option>
            </select>
          </div>
          <div class="sub-setting">
            <label>ğŸ“ Ø³Ø§ÛŒØ²:</label>
            <input type="range" id="subSize" min="16" max="48" value="24" oninput="updateSubStyle()">
            <span id="subSizeVal">24px</span>
          </div>
          <div class="sub-setting">
            <label>ğŸ¨ Ø±Ù†Ú¯:</label>
            <input type="color" id="subColor" value="#ffffff" oninput="updateSubStyle()">
          </div>
          <div class="sub-setting">
            <label>ğŸ–¼ï¸ Ø¨Ú©:</label>
            <select id="subBg" onchange="updateSubStyle()">
              <option value="rgba(0,0,0,0.8)">ØªÛŒØ±Ù‡</option>
              <option value="rgba(0,0,0,0.5)">Ù†ÛŒÙ…Ù‡</option>
              <option value="transparent">Ø´ÙØ§Ù</option>
            </select>
          </div>
          <div class="sub-setting">
            <label>â±ï¸ ØªØ§Ø®ÛŒØ±:</label>
            <button class="delay-btn" onclick="adjustDelay(-0.5)">-</button>
            <span id="delayVal">0s</span>
            <button class="delay-btn" onclick="adjustDelay(0.5)">+</button>
          </div>
          <div class="sub-setting">
            <button class="sub-remove-btn" onclick="removeSubtitle()">âŒ Ø­Ø°Ù</button>
          </div>
        </div>
      </div>

      <div class="subtitle-section" id="subtitleSection">
        <div class="subtitle-header" onclick="toggleSubtitlePanel()">
          <span class="icon">ğŸ’¬</span>
          <span class="title">Ø²ÛŒØ±Ù†ÙˆÛŒØ³</span>
          <span class="toggle" id="subToggle">â–¼ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù†</span>
        </div>
        <div class="subtitle-content" id="subtitleContent">
          <div class="sub-search-row">
            <input type="text" id="imdbInput" placeholder="IMDB ID (Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø± Ù…ÛŒØ´Ù‡)" style="display:none;" />
            <button class="btn" id="searchSubBtn" style="width:100%;">ğŸ” Ø¬Ø³ØªØ¬ÙˆÛŒ Ø²ÛŒØ±Ù†ÙˆÛŒØ³</button>
          </div>
          <div class="sub-search-row" style="margin-top:10px; direction:ltr;">
            <input type="text" id="srtUrlInput" placeholder="Paste SRT URL here..." style="flex:1; text-align:left;" />
            <button class="btn" id="loadSrtBtn" style="width:auto; padding:12px 15px;">ğŸ“¥ Load</button>
          </div>
          <div id="subStatus" class="sub-status"></div>
          <div id="langContainer"></div>
          <div id="subListContainer"></div>
          <div id="filePickerContainer"></div>
        </div>
      </div>

      <div id="selectionArea"></div>

      <footer class="footer">
        <div class="credit">
          <span>ğŸ’œ</span>
          <span>ØªÙˆØ³Ø·</span>
          <span class="credit-name">Ø¢Ù‚Ø§ Ø¯ÙÙ†ÛŒ</span>
        </div>
      </footer>
    </div>

    <script>
      const $ = id => document.getElementById(id);
      const urlInput = $("url");
      const btn = $("btn");
      const loader = $("loader");
      const player = $("player");
      const video = $("video");
      const statusEl = $("status");
      const selectionArea = $("selectionArea");
      const backToMovie = $("backToMovie");

      let telegramData = null;
      let selectedSubType = null;
      let selectedQuality = null;
      let sourceType = null; // 'telegram' or 'farsiland'

      const setStatus = (msg, type) => {
        statusEl.textContent = msg;
        statusEl.className = "status " + type;
      };

      function play(link) {
        if (!link) return setStatus("Ù„ÛŒÙ†Ú© Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯", "error");
        btn.disabled = true;
        loader.classList.add("show");
        player.classList.remove("show");
        setStatus("Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...", "loading");

        video.src = "/stream?url=" + encodeURIComponent(link);
        video.onloadeddata = () => {
          loader.classList.remove("show");
          player.classList.add("show");
          setStatus("Ø¢Ù…Ø§Ø¯Ù‡ Ù¾Ø®Ø´ âœ“", "success");
          btn.disabled = false;
          video.play().catch(() => {});
        };
        video.onerror = () => {
          loader.classList.remove("show");
          setStatus("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ", "error");
          btn.disabled = false;
        };
      }

      btn.onclick = () => play(urlInput.value.trim());
      urlInput.onkeypress = e => { if (e.key === "Enter") btn.click(); };
      function groupBySubType(downloads) {
        const groups = {
          dubbed: { label: 'Dubbed (Ø¯ÙˆØ¨Ù„Ù‡)', icon: 'ğŸ™ï¸', items: [] },
          softsub: { label: 'SoftSub (Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ø¬Ø¯Ø§)', icon: 'ğŸ’¬', items: [] },
          hardsub: { label: 'HardSub (Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ú†Ø³Ø¨ÛŒØ¯Ù‡)', icon: 'ğŸ“', items: [] },
          other: { label: 'Other (Ø³Ø§ÛŒØ±)', icon: 'ğŸ“¦', items: [] }
        };
        downloads.forEach(dl => {
          if (dl.subType === 'dubbed') groups.dubbed.items.push(dl);
          else if (dl.subType === 'softsub') groups.softsub.items.push(dl);
          else if (dl.subType === 'hardsub') groups.hardsub.items.push(dl);
          else groups.other.items.push(dl);
        });
        return groups;
      }

      function getQualityKey(dl) {
        let key = dl.quality ? `${dl.quality}p` : '0p';
        if (dl.codec) key += ` ${dl.codec}`;
        if (dl.source) key += ` ${dl.source}`;
        return key;
      }

      function groupByQuality(items) {
        const groups = {};
        items.forEach(dl => {
          const key = getQualityKey(dl);
          if (!groups[key]) groups[key] = [];
          groups[key].push(dl);
        });
        return Object.fromEntries(
          Object.entries(groups).sort((a, b) => {
            const qa = parseInt(a[0].match(/(\d+)p/)?.[1] || 0);
            const qb = parseInt(b[0].match(/(\d+)p/)?.[1] || 0);
            return qb - qa;
          })
        );
      }

      function formatSize(bytes) {
        if (!bytes) return "";
        const gb = bytes / (1024 * 1024 * 1024);
        if (gb >= 1) return `${gb.toFixed(1)} GB`;
        return `${(bytes / (1024 * 1024)).toFixed(0)} MB`;
      }

      function renderSelection() {
        if (!telegramData || !telegramData.downloads) {
          selectionArea.innerHTML = '';
          return;
        }

        const downloads = telegramData.downloads;
        const isSeries = telegramData.type === "series" || downloads.some(d => d.episode);
        const subTypeGroups = groupBySubType(downloads);

        let html = '<div class="selection-area">';
        if (!selectedSubType) {
          html += `
            <div class="step-header">
              <span class="step-num">1</span>
              <span class="step-title">Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹</span>
            </div>
            <div class="type-grid">
          `;
          for (const [key, group] of Object.entries(subTypeGroups)) {
            if (group.items.length === 0) continue;
            const qualityGroups = groupByQuality(group.items);
            const qCount = Object.keys(qualityGroups).length;
            const epCount = new Set(group.items.map(d => d.episode)).size;
            html += `
              <div class="type-card" onclick="selectType('${key}')">
                <span class="icon">${group.icon}</span>
                <div class="info">
                  <div class="label">${group.label}</div>
                  <div class="meta">${qCount} Ú©ÛŒÙÛŒØª â€¢ ${isSeries ? epCount + ' Ù‚Ø³Ù…Øª' : group.items.length + ' ÙØ§ÛŒÙ„'}</div>
                </div>
              </div>
            `;
          }
          html += '</div>';
        }
        else if (!selectedQuality) {
          const group = subTypeGroups[selectedSubType];
          const qualityGroups = groupByQuality(group.items);

          html += `
            <div class="current-selection">
              <span class="sel-tag">${group.icon} ${group.label}</span>
            </div>
            <div class="step-header">
              <span class="step-num">2</span>
              <span class="step-title">Ø§Ù†ØªØ®Ø§Ø¨ Ú©ÛŒÙÛŒØª</span>
              <span class="back-link" onclick="goBack('type')">â† Ø¨Ø±Ú¯Ø´Øª</span>
            </div>
            <div class="quality-grid">
          `;
          for (const [qKey, items] of Object.entries(qualityGroups)) {
            const epCount = new Set(items.map(d => d.episode)).size;
            const totalSize = items.reduce((s, d) => s + (d.sizeBytes || 0), 0);
            const avgSize = items.length > 0 ? formatSize(totalSize / items.length) : '';
            html += `
              <div class="quality-card" onclick="selectQuality('${qKey.replace(/'/g, "\\'")}')">
                <span class="q-name">${qKey}</span>
                <span class="q-meta">${isSeries ? epCount + ' Ù‚Ø³Ù…Øª' : items.length + ' ÙØ§ÛŒÙ„'}</span>
                ${avgSize ? `<span class="q-size">~${avgSize}</span>` : ''}
              </div>
            `;
          }
          html += '</div>';
        }
        else {
          const group = subTypeGroups[selectedSubType];
          const qualityGroups = groupByQuality(group.items);
          const items = qualityGroups[selectedQuality] || [];

          html += `
            <div class="current-selection">
              <span class="sel-tag">${group.icon} ${group.label}</span>
              <span class="sel-tag">ğŸ“€ ${selectedQuality}</span>
            </div>
            <div class="step-header">
              <span class="step-num">3</span>
              <span class="step-title">${isSeries ? 'Ø§Ù†ØªØ®Ø§Ø¨ Ù‚Ø³Ù…Øª' : 'Ø¯Ø§Ù†Ù„ÙˆØ¯'}</span>
              <span class="back-link" onclick="goBack('quality')">â† Ø¨Ø±Ú¯Ø´Øª</span>
            </div>
            <div class="episode-grid">
          `;

          items.sort((a, b) => (a.episode || 999) - (b.episode || 999));
          items.forEach((dl, idx) => {
            const epLabel = dl.episode ? `E${String(dl.episode).padStart(2, '0')}` : (isSeries ? 'DL' : dl.size || 'Ø¯Ø§Ù†Ù„ÙˆØ¯');
            html += `
              <div class="ep-card" onclick="playEpisode(${idx})" data-idx="${idx}">
                <span class="ep-num">${epLabel}</span>
                <span class="ep-size">${dl.size || ''}</span>
              </div>
            `;
          });
          html += '</div>';
        }

        html += '</div>';
        selectionArea.innerHTML = html;
      }

      window.selectType = function(type) {
        selectedSubType = type;
        selectedQuality = null;
        renderSelection();
      };

      window.selectQuality = function(quality) {
        selectedQuality = quality;
        renderSelection();
      };

      window.goBack = function(level) {
        if (level === 'type') {
          selectedSubType = null;
          selectedQuality = null;
        } else if (level === 'quality') {
          selectedQuality = null;
        }
        renderSelection();
      };

      window.playEpisode = function(idx) {
        const group = groupBySubType(telegramData.downloads)[selectedSubType];
        const qualityGroups = groupByQuality(group.items);
        const items = qualityGroups[selectedQuality] || [];
        items.sort((a, b) => (a.episode || 999) - (b.episode || 999));
        const dl = items[idx];
        if (dl && dl.url) {
          document.querySelectorAll('.ep-card').forEach(c => c.classList.remove('active'));
          document.querySelector(`.ep-card[data-idx="${idx}"]`)?.classList.add('active');
          play(dl.url);
        }
      };
      async function playFromFileId(dl) {
        if (!dl || !dl.fileId) return;
        try {
          const res = await fetch(`/api/get-download?fileId=${encodeURIComponent(dl.fileId)}`);
          const data = await res.json();
          if (data.success && data.downloadUrl) {
            play(data.downloadUrl);
          } else {
            setStatus("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú©", "error");
          }
        } catch (e) {
          setStatus("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„", "error");
        }
      }

      function initFarsilandPlayer(streamData) {
        if (!streamData || !Array.isArray(streamData.downloads)) return;
        selectionArea.innerHTML = '';
        
        const sorted = streamData.downloads.slice().sort((a, b) => parseInt(b.quality) - parseInt(a.quality));
        let html = '<div class="selection-area"><div class="step-header"><span class="step-num">ğŸ“€</span><span class="step-title">Ø§Ù†ØªØ®Ø§Ø¨ Ú©ÛŒÙÛŒØª</span></div><div class="episode-grid">';
        
        sorted.forEach((dl, idx) => {
          const qLabel = dl.quality ? `${dl.quality}p` : "Ú©ÛŒÙÛŒØª";
          const sizePart = dl.size ? ` â€¢ ${dl.size}` : "";
          html += `<div class="ep-card" onclick="playFarsiland(${idx})" data-idx="${idx}"><span class="ep-num">${qLabel}</span><span class="ep-size">${dl.size || ''}</span></div>`;
        });
        
        html += '</div></div>';
        selectionArea.innerHTML = html;
        
        window.playFarsiland = function(idx) {
          document.querySelectorAll('.ep-card').forEach(c => c.classList.remove('active'));
          document.querySelector(`.ep-card[data-idx="${idx}"]`)?.classList.add('active');
          playFromFileId(sorted[idx]);
        };
        
        if (sorted[0]) {
          document.querySelector('.ep-card[data-idx="0"]')?.classList.add('active');
          playFromFileId(sorted[0]);
        }
      }
      const params = new URLSearchParams(window.location.search);
      const autoUrl = params.get("url");
      const source = params.get("source");
      const imdbId = params.get("imdb");
      let currentSubtitleTrack = null;
      let subtitleDelay = 0;
      let subtitleLanguages = [];
      let currentSubtitles = [];
      let currentCacheKey = null;
      let parsedCues = [];
      let useCustomOverlay = true;
      function toggleSubtitlePanel() {
        const content = $("subtitleContent");
        const toggle = $("subToggle");
        content.classList.toggle("show");
        toggle.textContent = content.classList.contains("show") ? "â–² Ø¨Ø³ØªÙ†" : "â–¼ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù†";
      }

      function setSubStatus(msg, type) {
        const el = $("subStatus");
        el.textContent = msg;
        el.className = "sub-status " + type;
      }

      async function searchSubtitles(retryCount = 0) {
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 1500; // 1.5 seconds
        
        let imdb = $("imdbInput").value.trim();
        let season = null;
        let title = null;
        let type = "movie"; // default to movie
        if (!imdb) {
          try {
            const td = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
            const fd = JSON.parse(localStorage.getItem("farsiland-current-stream") || "{}");
            imdb = td.imdbId || fd.imdbId || "";
            season = td.season || fd.season || null;
            title = td.title || fd.title || null;
            type = td.type || fd.type || "movie";
            if (imdb) $("imdbInput").value = imdb;
            console.log("ğŸ“¦ From localStorage - imdb:", imdb, "season:", season, "title:", title, "type:", type);
          } catch (e) { console.error(e); }
        } else {
          try {
            const td = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
            const fd = JSON.parse(localStorage.getItem("farsiland-current-stream") || "{}");
            season = td.season || fd.season || null;
            title = td.title || fd.title || null;
            type = td.type || fd.type || "movie";
            console.log("ğŸ“¦ Season from localStorage:", season, "title:", title, "type:", type);
          } catch (e) { console.error(e); }
        }
        
        if (!imdb) return setSubStatus("âŒ IMDB ID Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ - Ø§Ø¨ØªØ¯Ø§ ÙÛŒÙ„Ù… Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯", "error");
        const isMovie = type === "movie";
        if (isMovie) {
          season = null;
          console.log("ğŸ¬ Movie detected, ignoring season");
        }
        
        const retryText = retryCount > 0 ? ` (ØªÙ„Ø§Ø´ ${retryCount + 1}/${MAX_RETRIES})` : '';
        setSubStatus(`Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ... ${isMovie ? '(ÙÛŒÙ„Ù…)' : '(ÙØµÙ„ ' + (season || '?') + ')'}${retryText}`, "loading");
        
        if (retryCount === 0) {
          $("langContainer").innerHTML = "";
          $("subListContainer").innerHTML = "";
          $("filePickerContainer").innerHTML = "";
        }
        
        try {
          let url = `/subtitle/search?imdbId=${encodeURIComponent(imdb)}`;
          if (season) url += `&season=${encodeURIComponent(season)}`;
          if (title) url += `&title=${encodeURIComponent(title)}`;
          console.log("ğŸ” Searching:", url, retryCount > 0 ? `(retry ${retryCount})` : '');
          const res = await fetch(url);
          const data = await res.json();
          
          if (!data.success || !data.languages || data.languages.length === 0) {
            if (retryCount < MAX_RETRIES - 1) {
              console.log(`â³ No results, retrying in ${RETRY_DELAY}ms... (${retryCount + 1}/${MAX_RETRIES})`);
              setSubStatus(`Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ØŒ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯... (${retryCount + 2}/${MAX_RETRIES})`, "loading");
              await new Promise(r => setTimeout(r, RETRY_DELAY));
              return searchSubtitles(retryCount + 1);
            }
            return setSubStatus("Ø²ÛŒØ±Ù†ÙˆÛŒØ³ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯", "error");
          }
          
          subtitleLanguages = data.languages;
          const seasonInfo = data.selectedSeason ? ` (ÙØµÙ„ ${data.selectedSeason})` : '';
          setSubStatus(`${data.languages.length} Ø²Ø¨Ø§Ù† Ù¾ÛŒØ¯Ø§ Ø´Ø¯${seasonInfo}`, "success");
          renderLanguages();
        } catch (e) {
          if (retryCount < MAX_RETRIES - 1) {
            console.log(`â³ Error, retrying in ${RETRY_DELAY}ms... (${retryCount + 1}/${MAX_RETRIES}):`, e.message);
            setSubStatus(`Ø®Ø·Ø§ØŒ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯... (${retryCount + 2}/${MAX_RETRIES})`, "loading");
            await new Promise(r => setTimeout(r, RETRY_DELAY));
            return searchSubtitles(retryCount + 1);
          }
          setSubStatus("Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬Ùˆ: " + e.message, "error");
        }
      }

      function renderLanguages() {
        const persian = subtitleLanguages.find(l => l.code === "farsi_persian");
        const english = subtitleLanguages.find(l => l.code === "english");
        const others = subtitleLanguages.filter(l => l.code !== "farsi_persian" && l.code !== "english");
        
        let html = '<div class="lang-grid">';
        
        if (persian) {
          const idx = subtitleLanguages.indexOf(persian);
          html += `<button class="lang-btn" onclick="selectLanguage(${idx})">ğŸ‡®ğŸ‡· ÙØ§Ø±Ø³ÛŒ <span class="count">${persian.count}</span></button>`;
        }
        if (english) {
          const idx = subtitleLanguages.indexOf(english);
          html += `<button class="lang-btn" onclick="selectLanguage(${idx})">ğŸ‡¬ğŸ‡§ English <span class="count">${english.count}</span></button>`;
        }
        if (others.length > 0) {
          html += `<button class="lang-btn" onclick="toggleOtherLangs()">ğŸŒ Ø³Ø§ÛŒØ± Ø²Ø¨Ø§Ù†â€ŒÙ‡Ø§ (${others.length}) â–¼</button>`;
        }
        
        html += '</div>';
        if (others.length > 0) {
          html += '<div id="otherLangsPanel" class="lang-grid" style="display:none; margin-top:8px;">';
          others.forEach(lang => {
            const idx = subtitleLanguages.indexOf(lang);
            html += `<button class="lang-btn" onclick="selectLanguage(${idx})">${lang.name} <span class="count">${lang.count}</span></button>`;
          });
          html += '</div>';
        }
        
        $("langContainer").innerHTML = html;
        if (persian) {
          selectLanguage(subtitleLanguages.indexOf(persian));
        }
      }
      
      function toggleOtherLangs() {
        const panel = $("otherLangsPanel");
        if (panel) {
          panel.style.display = panel.style.display === "none" ? "flex" : "none";
        }
      }

      async function selectLanguage(idx) {
        const lang = subtitleLanguages[idx];
        if (!lang) return;
        document.querySelectorAll(".lang-btn").forEach((btn, i) => {
          btn.classList.toggle("active", i === idx);
        });
        
        setSubStatus(`Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª ${lang.name}...`, "loading");
        $("subListContainer").innerHTML = "";
        $("filePickerContainer").innerHTML = "";
        
        try {
          const res = await fetch(`/subtitle/list?url=${encodeURIComponent(lang.url)}`);
          const data = await res.json();
          
          if (!data.success || !data.subtitles || data.subtitles.length === 0) {
            return setSubStatus("Ø²ÛŒØ±Ù†ÙˆÛŒØ³ÛŒ Ø¯Ø± Ø§ÛŒÙ† Ø²Ø¨Ø§Ù† Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯", "error");
          }
          
          currentSubtitles = data.subtitles;
          setSubStatus(`${data.subtitles.length} Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ù¾ÛŒØ¯Ø§ Ø´Ø¯`, "success");
          renderSubtitleList();
        } catch (e) {
          setSubStatus("Ø®Ø·Ø§: " + e.message, "error");
        }
      }

      function renderSubtitleList() {
        let html = '<div class="sub-list">';
        currentSubtitles.forEach((sub, idx) => {
          const ratingClass = sub.rating === "good" ? "good" : "neutral";
          const releasesText = sub.releases.slice(0, 2).join(" â€¢ ");
          html += `
            <div class="sub-item" onclick="selectSubtitle(${idx})">
              <span class="rating ${ratingClass}"></span>
              <div class="info">
                <div class="releases">${releasesText || "Ø¨Ø¯ÙˆÙ† Ù†Ø§Ù…"}</div>
                <div class="meta">
                  <span class="author">ğŸ‘¤ ${sub.author || "Ù†Ø§Ø´Ù†Ø§Ø³"}</span>
                  ${sub.comment ? ` â€¢ ${sub.comment.slice(0, 50)}...` : ""}
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
        $("subListContainer").innerHTML = html;
      }

      async function selectSubtitle(idx) {
        const sub = currentSubtitles[idx];
        if (!sub || !sub.downloadUrl) return;
        
        setSubStatus("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª ØµÙØ­Ù‡ Ø¯Ø§Ù†Ù„ÙˆØ¯...", "loading");
        
        try {
          const pageRes = await fetch(`/subtitle/download-page?url=${encodeURIComponent(sub.downloadUrl)}`);
          const pageData = await pageRes.json();
          
          if (!pageData.success || !pageData.downloadLink) {
            return setSubStatus("Ù„ÛŒÙ†Ú© Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯", "error");
          }
          
          setSubStatus("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ùˆ Ø§Ø³ØªØ®Ø±Ø§Ø¬...", "loading");
          const extractRes = await fetch(`/subtitle/extract?url=${encodeURIComponent(pageData.downloadLink)}`);
          const extractData = await extractRes.json();
          
          if (!extractData.success || !extractData.files || extractData.files.length === 0) {
            return setSubStatus("ÙØ§ÛŒÙ„ Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ø¯Ø± Ø¢Ø±Ø´ÛŒÙˆ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯", "error");
          }
          
          currentCacheKey = extractData.cacheKey;
          setSubStatus(`${extractData.files.length} ÙØ§ÛŒÙ„ Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ù¾ÛŒØ¯Ø§ Ø´Ø¯`, "success");
          renderFilePicker(extractData.files);
        } catch (e) {
          setSubStatus("Ø®Ø·Ø§: " + e.message, "error");
        }
      }

      function renderFilePicker(files) {
        let html = '<div class="file-picker"><div class="file-picker-title">ğŸ“ Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„ Ø²ÛŒØ±Ù†ÙˆÛŒØ³:</div>';
        files.forEach((file, idx) => {
          const sizeMB = (file.size / 1024).toFixed(1);
          html += `<button class="file-btn" onclick="loadSubtitleFile(${file.index}, this)">
            ${file.name} <span style="color:var(--muted)">(${sizeMB} KB)</span>
          </button>`;
        });
        html += '</div>';
        $("filePickerContainer").innerHTML = html;
      }

      async function loadSubtitleFile(index, btn) {
        if (!currentCacheKey) return setSubStatus("Ø®Ø·Ø§: Ú©Ø´ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡", "error");
        
        setSubStatus("Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø²ÛŒØ±Ù†ÙˆÛŒØ³...", "loading");
        document.querySelectorAll(".file-btn").forEach(b => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
        
        try {
          const url = `/subtitle/file?cacheKey=${encodeURIComponent(currentCacheKey)}&index=${index}`;
          removeSubtitle();
          const res = await fetch(url);
          const vttText = await res.text();
          parsedCues = parseVTT(vttText);
          
          if (parsedCues.length === 0) {
            return setSubStatus("Ø®Ø·Ø§: Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª", "error");
          }
          video.addEventListener("timeupdate", renderSubtitleOverlay);
          video.addEventListener("seeking", renderSubtitleOverlay);
          
          setSubStatus(`âœ“ Ø²ÛŒØ±Ù†ÙˆÛŒØ³ ÙØ¹Ø§Ù„ Ø´Ø¯ (${parsedCues.length} Ø®Ø·)`, "success");
          $("subSettingsBar").style.display = "block"; // Show settings bar
          updateSubStyle();
        } catch (e) {
          setSubStatus("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ: " + e.message, "error");
        }
      }
      
      function parseVTT(vtt) {
        const cues = [];
        const lines = vtt.split("\n");
        let i = 0;
        while (i < lines.length && !lines[i].includes("-->")) i++;
        
        while (i < lines.length) {
          const line = lines[i].trim();
          if (line.includes("-->")) {
            const [startStr, endStr] = line.split("-->").map(s => s.trim());
            const start = parseTime(startStr);
            const end = parseTime(endStr);
            const textLines = [];
            i++;
            while (i < lines.length && lines[i].trim() !== "" && !lines[i].includes("-->")) {
              textLines.push(lines[i].trim());
              i++;
            }
            
            if (textLines.length > 0) {
              cues.push({ start, end, text: textLines.join("\n") });
            }
          } else {
            i++;
          }
        }
        return cues;
      }
      
      function parseTime(str) {
        const parts = str.split(":");
        if (parts.length === 3) {
          const [h, m, s] = parts;
          return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);
        } else if (parts.length === 2) {
          const [m, s] = parts;
          return parseFloat(m) * 60 + parseFloat(s);
        }
        return 0;
      }
      
      function renderSubtitleOverlay() {
        const time = video.currentTime + subtitleDelay;
        const overlay = $("subtitleText");
        if (!overlay) return;
        const cue = parsedCues.find(c => time >= c.start && time <= c.end);
        
        if (cue) {
          let text = cue.text.replace(/<[^>]+>/g, "");
          overlay.innerHTML = text;
        } else {
          overlay.innerHTML = "";
        }
      }

      function removeSubtitle() {
        video.removeEventListener("timeupdate", renderSubtitleOverlay);
        video.removeEventListener("seeking", renderSubtitleOverlay);
        parsedCues = [];
        const overlay = $("subtitleText");
        if (overlay) overlay.innerHTML = "";
        if (currentSubtitleTrack) {
          currentSubtitleTrack.remove();
          currentSubtitleTrack = null;
        }
        const tracks = video.querySelectorAll("track");
        tracks.forEach(t => t.remove());
        
        $("subSettingsBar").style.display = "none";
        setSubStatus("Ø²ÛŒØ±Ù†ÙˆÛŒØ³ Ø­Ø°Ù Ø´Ø¯", "success");
      }

      function toggleSettings() {
        const settings = $("subSettings");
        settings.style.display = settings.style.display === "none" ? "flex" : "none";
      }

      function updateSubStyle() {
        const size = $("subSize").value;
        const color = $("subColor").value;
        const bg = $("subBg").value;
        const font = $("subFont")?.value || '"ShabnamLightFD", Tahoma';
        const position = $("subPosition")?.value || "80px";
        
        $("subSizeVal").textContent = size + "px";
        const overlay = $("subtitleText");
        const overlayContainer = $("subtitleOverlay");
        if (overlay) {
          overlay.style.fontSize = size + "px";
          overlay.style.color = color;
          overlay.style.backgroundColor = bg;
          overlay.style.fontFamily = font;
          overlay.style.lineHeight = "1.5";
          overlay.style.padding = "10px 20px";
          overlay.style.borderRadius = "8px";
        }
        if (overlayContainer) {
          overlayContainer.style.bottom = position;
        }
        try {
          localStorage.setItem("sub-settings", JSON.stringify({ size, color, bg, font, position }));
        } catch(e) {}
      }
      function loadSubSettings() {
        try {
          const saved = JSON.parse(localStorage.getItem("sub-settings") || "{}");
          if (saved.size) $("subSize").value = saved.size;
          if (saved.color) $("subColor").value = saved.color;
          if (saved.bg) $("subBg").value = saved.bg;
          if (saved.font) $("subFont").value = saved.font;
          if (saved.position) $("subPosition").value = saved.position;
          updateSubStyle();
        } catch(e) {}
      }
      loadSubSettings();
      
      function adjustDelay(delta) {
        subtitleDelay += delta;
        const delayEl = $("delayVal");
        if (delayEl) delayEl.textContent = subtitleDelay.toFixed(1) + "s";
        renderSubtitleOverlay();
      }
      $("searchSubBtn").onclick = searchSubtitles;
      $("imdbInput").onkeypress = e => { if (e.key === "Enter") searchSubtitles(); };
      $("loadSrtBtn").onclick = loadSrtFromUrl;
      $("srtUrlInput").onkeypress = e => { if (e.key === "Enter") loadSrtFromUrl(); };
      async function loadSrtFromUrl() {
        const url = $("srtUrlInput").value.trim();
        if (!url) return setSubStatus("Please enter an SRT URL", "error");
        
        setSubStatus("Loading subtitle from URL...", "loading");
        
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const srtText = await res.text();
          
          if (!srtText || srtText.length < 10) {
            return setSubStatus("Invalid or empty SRT file", "error");
          }
          parsedCues = parseSRT(srtText);
          if (parsedCues.length === 0) {
            return setSubStatus("Could not parse SRT file", "error");
          }
          
          useCustomOverlay = true;
          subtitleDelay = 0;
          showSubSettingsBar();
          setSubStatus(`âœ… Loaded ${parsedCues.length} subtitle cues`, "success");
          $("langContainer").innerHTML = "";
          $("subListContainer").innerHTML = "";
          $("filePickerContainer").innerHTML = "";
          
        } catch (e) {
          setSubStatus("Error loading URL: " + e.message, "error");
        }
      }
      if (imdbId) {
        $("imdbInput").value = imdbId;
        toggleSubtitlePanel();
        setTimeout(searchSubtitles, 500);
      } else {
        try {
          const telegramData = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
          const farsilandData = JSON.parse(localStorage.getItem("farsiland-current-stream") || "{}");
          const storedImdb = telegramData.imdbId || farsilandData.imdbId;
          if (storedImdb) {
            $("imdbInput").value = storedImdb;
            toggleSubtitlePanel();
            setTimeout(searchSubtitles, 500);
          }
        } catch (e) {}
      }

      if (autoUrl) {
        urlInput.value = decodeURIComponent(autoUrl);
        play(decodeURIComponent(autoUrl));
      } else if (source === "telegram") {
        sourceType = 'telegram';
        try {
          telegramData = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
          if (telegramData.title) urlInput.placeholder = `Ù¾Ø®Ø´: ${telegramData.title}`;
          backToMovie.style.display = "inline-block";
          if (telegramData.imdbId) {
            backToMovie.href = `/telegram.html?restore=${telegramData.imdbId}`;
          } else {
            backToMovie.href = "/telegram.html";
          }
          renderSelection();
        } catch (e) {
          console.error(e);
        }
      } else {
        sourceType = 'farsiland';
        try {
          const streamData = JSON.parse(localStorage.getItem("farsiland-current-stream") || "null");
          if (streamData) {
            if (streamData.title) urlInput.placeholder = `Ù¾Ø®Ø´: ${streamData.title}`;
            if (streamData.source) {
              backToMovie.style.display = "inline-block";
              backToMovie.href = streamData.source;
            }
            if (streamData.downloads && streamData.downloads.length) {
              initFarsilandPlayer(streamData);
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
    </script>
  </body>
</html>
