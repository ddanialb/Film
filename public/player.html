<!DOCTYPE html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ŸÅ€åŸÑŸÖ ÿ®€åŸÜÿß - ŸæÿÆÿ¥ ÿ¢ŸÜŸÑÿß€åŸÜ</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --primary: #6366f1;
        --secondary: #8b5cf6;
        --bg: #0a0a0f;
        --card: rgba(20, 20, 30, 0.9);
        --border: rgba(255, 255, 255, 0.08);
        --text: #f1f1f1;
        --muted: #888;
      }
      @font-face {
        font-family: "ShabnamLightFD";
        src: url("/fonts/Shabnam-Light-FD.woff2") format("woff2"),
          url("/fonts/Shabnam-Light-FD.woff") format("woff");
        font-weight: 300;
        font-display: swap;
      }
      body {
        font-family: "ShabnamLightFD", system-ui, sans-serif;
        background: var(--bg);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        padding: 15px;
      }
      .container {
        background: var(--card);
        padding: 25px;
        border-radius: 20px;
        width: 100%;
        max-width: 950px;
        border: 1px solid var(--border);
      }
      .header {
        text-align: center;
        margin-bottom: 20px;
      }
      .logo {
        width: 50px;
        height: 50px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        border-radius: 14px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        margin-bottom: 10px;
      }
      h1 { color: var(--text); font-size: 22px; }
      .subtitle { margin-top: 5px; font-size: 12px; color: var(--muted); }
      .nav-row {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 12px;
        flex-wrap: wrap;
      }
      .nav-btn {
        padding: 8px 18px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--border);
        border-radius: 20px;
        color: var(--text);
        text-decoration: none;
        font-size: 13px;
        transition: all 0.2s;
      }
      .nav-btn:hover { background: rgba(255,255,255,0.15); }
      .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-direction: row-reverse;
      }
      input {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.3);
        color: var(--text);
        font-size: 14px;
        outline: none;
        direction: ltr;
        text-align: left;
      }
      input:focus { border-color: var(--primary); }
      .btn {
        padding: 12px 25px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: #fff;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
      }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .loader { display: none; justify-content: center; padding: 25px; }
      .loader.show { display: flex; }
      .spinner {
        width: 35px;
        height: 35px;
        border: 3px solid var(--border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin { to { transform: rotate(360deg); } }
      .video-container {
        display: none;
        border-radius: 14px;
        overflow: hidden;
        background: #000;
        margin-bottom: 15px;
        position: relative;
      }
      .video-container.show { display: block; }
      
      video { width: 100%; display: block; }
      /* Hide native fullscreen button */
      video::-webkit-media-controls-fullscreen-button { display: none !important; }
      video::-webkit-media-controls-toggle-closed-captions-button { display: none !important; }
      
      /* Custom subtitle overlay */
      .subtitle-overlay {
        position: absolute;
        bottom: 80px;
        left: 0;
        right: 0;
        text-align: center;
        pointer-events: none;
        z-index: 9999;
        padding: 0 20px;
        transition: bottom 0.1s ease-out;
      }
      
      .subtitle-text {
        display: inline-block;
        padding: 10px 20px;
        border-radius: 6px;
        max-width: 85%;
        white-space: pre-wrap;
        direction: auto;
        unicode-bidi: plaintext;
        font-family: "ShabnamLightFD", Tahoma, Arial, sans-serif;
        font-size: 22px;
        color: #fff;
        background: rgba(0,0,0,0.85);
        text-shadow: 2px 2px 4px #000;
        pointer-events: auto;
        cursor: grab;
        user-select: none;
      }
      .subtitle-text:active { cursor: grabbing; }
      .subtitle-text:empty { display: none; pointer-events: none; }
      
      /* Fullscreen styles */
      .video-container:fullscreen,
      .video-container:-webkit-full-screen {
        width: 100vw !important;
        height: 100vh !important;
        background: #000;
      }
      
      .video-container:fullscreen video,
      .video-container:-webkit-full-screen video {
        width: 100vw !important;
        height: 100vh !important;
        object-fit: contain;
      }
      
      .video-container:fullscreen .subtitle-overlay,
      .video-container:-webkit-full-screen .subtitle-overlay {
        position: fixed;
        bottom: 120px;
        left: 0;
        right: 0;
        z-index: 2147483647;
      }
      
      .video-container:fullscreen .subtitle-text,
      .video-container:-webkit-full-screen .subtitle-text {
        font-size: 28px;
        padding: 12px 24px;
      }
      
      /* Custom fullscreen button */
      .custom-fullscreen-btn {
        position: absolute;
        bottom: 35px;
        right: 170px;
        width: 30px;
        height: 30px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        z-index: 9998;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      }
      .custom-fullscreen-btn.visible {
        opacity: 1;
        pointer-events: auto;
      }
      .custom-fullscreen-btn:hover { color: #a5b4fc; }
      
      .video-container:fullscreen .custom-fullscreen-btn,
      .video-container:-webkit-full-screen .custom-fullscreen-btn {
        position: fixed;
        bottom: 43px;
        right: 220px;
        font-size: 24px;
      }
      
      .status {
        text-align: center;
        font-size: 13px;
        padding: 8px;
        border-radius: 8px;
        margin-bottom: 15px;
      }
      .status:empty { display: none; }
      .status.error { background: rgba(239, 68, 68, 0.1); color: #f87171; }
      .status.success { background: rgba(34, 197, 94, 0.1); color: #4ade80; }
      .status.loading { background: rgba(234, 179, 8, 0.1); color: #facc15; }
      
      /* Selection UI */
      .selection-area {
        background: rgba(0,0,0,0.2);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
      }
      .step-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .step-num {
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, #feca57, #ff9f43);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        color: #000;
      }
      .step-title { color: #feca57; font-size: 14px; font-weight: bold; }
      .back-link {
        margin-right: auto;
        color: var(--muted);
        font-size: 12px;
        cursor: pointer;
        text-decoration: underline;
      }
      .back-link:hover { color: var(--text); }
      
      /* Type buttons */
      .type-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
      }
      .type-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        background: linear-gradient(135deg, rgba(99,102,241,0.12), rgba(139,92,246,0.12));
        border: 2px solid rgba(99,102,241,0.25);
        border-radius: 12px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      }
      .type-card:hover {
        background: linear-gradient(135deg, rgba(99,102,241,0.25), rgba(139,92,246,0.25));
        border-color: rgba(99,102,241,0.5);
        transform: translateY(-2px);
      }
      .type-card .icon { font-size: 1.8rem; }
      .type-card .info { flex: 1; }
      .type-card .label { font-weight: bold; font-size: 14px; }
      .type-card .meta { font-size: 11px; color: var(--muted); margin-top: 3px; }
      
      /* Quality buttons */
      .quality-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 10px;
      }
      .quality-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        padding: 16px 12px;
        background: linear-gradient(135deg, rgba(162,155,254,0.12), rgba(129,140,248,0.12));
        border: 2px solid rgba(162,155,254,0.25);
        border-radius: 12px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      }
      .quality-card:hover {
        background: linear-gradient(135deg, rgba(162,155,254,0.25), rgba(129,140,248,0.25));
        border-color: rgba(162,155,254,0.5);
        transform: translateY(-2px);
      }
      .quality-card .q-name { font-weight: bold; font-size: 13px; color: #a29bfe; }
      .quality-card .q-meta { font-size: 11px; color: var(--muted); }
      .quality-card .q-size { font-size: 10px; color: #2ecc71; background: rgba(46,204,113,0.15); padding: 2px 8px; border-radius: 8px; }
      
      /* Episode buttons */
      .episode-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .ep-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        padding: 10px 14px;
        background: rgba(255,255,255,0.05);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 70px;
      }
      .ep-card:hover {
        background: rgba(99,102,241,0.2);
        border-color: rgba(99,102,241,0.4);
      }
      .ep-card.active {
        background: linear-gradient(135deg, rgba(99,102,241,0.3), rgba(139,92,246,0.3));
        border-color: var(--primary);
        box-shadow: 0 0 15px rgba(99,102,241,0.3);
      }
      .ep-card .ep-num { font-weight: bold; font-size: 13px; color: var(--primary); }
      .ep-card .ep-size { font-size: 10px; color: var(--muted); }
      
      /* Current selection display */
      .current-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .sel-tag {
        padding: 5px 12px;
        background: rgba(254,202,87,0.15);
        border: 1px solid rgba(254,202,87,0.3);
        border-radius: 20px;
        font-size: 12px;
        color: #feca57;
      }
      
      /* Subtitle UI */
      .subtitle-section {
        background: rgba(0,0,0,0.3);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
      }
      .subtitle-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        cursor: pointer;
      }
      .subtitle-header .icon { font-size: 20px; }
      .subtitle-header .title { color: #feca57; font-weight: bold; font-size: 14px; }
      .subtitle-header .toggle { margin-right: auto; color: var(--muted); font-size: 12px; }
      .subtitle-content { display: none; }
      .subtitle-content.show { display: block; }
      
      .sub-search-row {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
      }
      .sub-search-row input {
        flex: 1;
        padding: 10px 14px;
        font-size: 13px;
      }
      .sub-search-row .btn {
        padding: 10px 18px;
        font-size: 13px;
      }
      
      .lang-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .lang-btn {
        padding: 8px 14px;
        background: rgba(99,102,241,0.15);
        border: 1px solid rgba(99,102,241,0.3);
        border-radius: 20px;
        color: #a5b4fc;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .lang-btn:hover, .lang-btn.active {
        background: rgba(99,102,241,0.3);
        border-color: var(--primary);
        color: #fff;
      }
      .lang-btn .count {
        background: rgba(0,0,0,0.3);
        padding: 2px 6px;
        border-radius: 10px;
        margin-right: 5px;
        font-size: 10px;
      }
      
      .sub-list {
        max-height: 300px;
        overflow-y: auto;
        padding-left: 8px;
      }
      .sub-list::-webkit-scrollbar {
        width: 6px;
      }
      .sub-list::-webkit-scrollbar-track {
        background: rgba(255,255,255,0.05);
        border-radius: 3px;
      }
      .sub-list::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.3);
        border-radius: 3px;
      }
      .sub-list::-webkit-scrollbar-thumb:hover {
        background: rgba(255,255,255,0.5);
      }
      .sub-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px;
        background: rgba(255,255,255,0.03);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .sub-item:hover {
        background: rgba(99,102,241,0.1);
        border-color: rgba(99,102,241,0.3);
      }
      .sub-item .rating {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-top: 6px;
        flex-shrink: 0;
      }
      .sub-item .rating.good { background: #4ade80; }
      .sub-item .rating.neutral, .sub-item .rating.not { background: #fbbf24; }
      .sub-item .info { flex: 1; min-width: 0; }
      .sub-item .releases {
        font-size: 12px;
        color: var(--text);
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .sub-item .meta {
        font-size: 11px;
        color: var(--muted);
      }
      .sub-item .author { color: #a78bfa; }
      
      .file-picker {
        background: rgba(0,0,0,0.2);
        border-radius: 10px;
        padding: 12px;
        margin-top: 10px;
      }
      .file-picker-title {
        font-size: 13px;
        color: #feca57;
        margin-bottom: 10px;
      }
      .file-btn {
        display: block;
        width: 100%;
        padding: 10px 14px;
        background: rgba(46,204,113,0.1);
        border: 1px solid rgba(46,204,113,0.3);
        border-radius: 8px;
        color: #4ade80;
        font-size: 12px;
        text-align: right;
        cursor: pointer;
        margin-bottom: 6px;
        transition: all 0.2s;
      }
      .file-btn:hover {
        background: rgba(46,204,113,0.2);
        border-color: rgba(46,204,113,0.5);
      }
      .file-btn.active {
        background: rgba(46,204,113,0.3);
        border-color: #4ade80;
      }
      
      .sub-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--border);
      }
      .sub-control-btn {
        padding: 6px 12px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 11px;
        cursor: pointer;
      }
      .sub-control-btn:hover { background: rgba(255,255,255,0.15); }
      .sub-control-btn.active { background: rgba(99,102,241,0.3); border-color: var(--primary); }
      
      .sub-settings {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-top: 12px;
        padding: 14px;
        background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(139,92,246,0.1));
        border: 1px solid rgba(99,102,241,0.2);
        border-radius: 10px;
      }
      .sub-settings-bar {
        background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.15));
        border: 1px solid rgba(99,102,241,0.3);
        border-radius: 12px;
        padding: 12px 15px;
        margin-bottom: 15px;
      }
      .sub-settings-bar .sub-settings-title {
        font-size: 13px;
        font-weight: bold;
        color: #a5b4fc;
        margin-bottom: 10px;
      }
      .sub-settings-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      .sub-settings-grid .sub-setting {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        font-size: 12px;
      }
      .sub-settings-grid .sub-setting label {
        color: var(--muted);
        font-size: 11px;
      }
      .sub-settings-grid select {
        padding: 4px 8px;
        background: rgba(0,0,0,0.4);
        border: 1px solid var(--border);
        border-radius: 5px;
        color: var(--text);
        font-size: 11px;
      }
      .sub-settings-grid input[type="range"] {
        width: 60px;
        accent-color: var(--primary);
      }
      .sub-settings-grid input[type="color"] {
        width: 28px;
        height: 24px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .sub-settings-grid #subSizeVal {
        color: #a5b4fc;
        font-size: 11px;
        min-width: 35px;
      }
      .sub-settings-grid #delayVal {
        color: #feca57;
        font-size: 11px;
        min-width: 30px;
        text-align: center;
      }
      .delay-btn {
        width: 24px;
        height: 24px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.3);
        color: var(--text);
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }
      .delay-btn:hover { background: rgba(99,102,241,0.3); }
      .sub-remove-btn {
        padding: 6px 12px;
        background: rgba(239,68,68,0.2);
        border: 1px solid rgba(239,68,68,0.3);
        color: #f87171;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }
      .sub-remove-btn:hover { background: rgba(239,68,68,0.4); }
      .sub-setting {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: rgba(0,0,0,0.2);
        border-radius: 8px;
      }
      .sub-setting label {
        font-size: 12px;
        color: var(--text);
        min-width: 50px;
      }
      .sub-setting input[type="range"] {
        flex: 1;
        min-width: 60px;
        padding: 0;
        accent-color: var(--primary);
      }
      .sub-setting input[type="color"] {
        width: 32px;
        height: 28px;
        padding: 0;
        border: 2px solid var(--border);
        border-radius: 6px;
        cursor: pointer;
        background: transparent;
      }
      .sub-setting select {
        flex: 1;
        padding: 6px 10px;
        background: rgba(0,0,0,0.4);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 12px;
      }
      
      .sub-status {
        font-size: 12px;
        padding: 8px;
        border-radius: 6px;
        margin-top: 10px;
        text-align: center;
      }
      .sub-status:empty { display: none; }
      .sub-status.loading { background: rgba(234,179,8,0.1); color: #facc15; }
      .sub-status.success { background: rgba(34,197,94,0.1); color: #4ade80; }
      .sub-status.error { background: rgba(239,68,68,0.1); color: #f87171; }
      
      .footer {
        margin-top: 20px;
        text-align: center;
        padding-top: 15px;
        border-top: 1px solid var(--border);
      }
      .credit {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: var(--text);
        font-size: 13px;
      }
      .credit-name {
        background: linear-gradient(135deg, #a78bfa, #60a5fa);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 700;
      }
      @media (max-width: 600px) {
        .container { padding: 15px; }
        .input-group { flex-direction: column; }
        .btn { width: 100%; }
        .type-grid { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header class="header">
        <div class="logo">‚ñ∂Ô∏è</div>
        <h1>ŸÅ€åŸÑŸÖ ÿ®€åŸÜÿß</h1>
        <p class="subtitle">ŸæÿÆÿ¥ ÿ¢ŸÜŸÑÿß€åŸÜ ŸÅ€åŸÑŸÖ Ÿà ÿ≥ÿ±€åÿßŸÑ</p>
        <div class="nav-row">
          <a href="/" class="nav-btn">üé¨ ŸÅ€åŸÑŸÖ ŸÅÿßÿ±ÿ≥€å</a>
          <a href="/telegram.html" class="nav-btn">üåç ŸÅ€åŸÑŸÖ ÿÆÿßÿ±ÿ¨€å</a>
          <a href="#" id="backToMovie" class="nav-btn" style="display:none;">‚Üê ÿ®ÿ±⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÅ€åŸÑŸÖ</a>
        </div>
      </header>

      <div class="input-group">
        <input type="text" id="url" placeholder="ŸÑ€åŸÜ⁄© Ÿà€åÿØ€åŸà ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ..." />
        <button class="btn" id="btn">‚ñ∂ ŸæÿÆÿ¥</button>
      </div>

      <div class="loader" id="loader"><div class="spinner"></div></div>
      <div class="video-container" id="player">
        <video id="video" controls playsinline></video>
        <div class="subtitle-overlay" id="subtitleOverlay">
          <span class="subtitle-text" id="subtitleText"></span>
        </div>
        <button class="custom-fullscreen-btn" id="fullscreenBtn" title="ÿ™ŸÖÿßŸÖ ÿµŸÅÿ≠Ÿá (ÿ®ÿß ÿ≤€åÿ±ŸÜŸà€åÿ≥)">‚õ∂</button>
      </div>
      <div class="status" id="status"></div>

      <div class="sub-settings-bar" id="subSettingsBar" style="display:none;">
        <div class="sub-settings-title">‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ≤€åÿ±ŸÜŸà€åÿ≥</div>
        <div class="sub-settings-grid">
          <div class="sub-setting">
            <label>‚úèÔ∏è ŸÅŸàŸÜÿ™:</label>
            <select id="subFont" onchange="updateSubStyle()">
              <option value="ShabnamLightFD, Tahoma">ÿ¥ÿ®ŸÜŸÖ</option>
              <option value="Tahoma, Arial">ÿ™ÿßŸáŸàŸÖÿß</option>
              <option value="Arial, sans-serif">Arial</option>
            </select>
          </div>
          <div class="sub-setting">
            <label>üìè ÿ≥ÿß€åÿ≤:</label>
            <input type="range" id="subSize" min="16" max="48" value="24" oninput="updateSubStyle()">
            <span id="subSizeVal">24px</span>
          </div>
          <div class="sub-setting">
            <label>üé® ÿ±ŸÜ⁄Ø:</label>
            <input type="color" id="subColor" value="#ffffff" oninput="updateSubStyle()">
          </div>
          <div class="sub-setting">
            <label>üñºÔ∏è ÿ®⁄©:</label>
            <input type="color" id="subBgColor" value="#000000" oninput="updateSubStyle()">
            <input type="range" id="subBgOpacity" min="0" max="100" value="85" oninput="updateSubStyle()" style="width:50px;">
            <span id="subBgOpacityVal">85%</span>
          </div>
          <div class="sub-setting">
            <label>‚è±Ô∏è ÿ™ÿßÿÆ€åÿ±:</label>
            <button class="delay-btn" onclick="adjustDelay(-0.5)">-</button>
            <span id="delayVal">0s</span>
            <button class="delay-btn" onclick="adjustDelay(0.5)">+</button>
          </div>
          <div class="sub-setting">
            <button class="sub-remove-btn" onclick="removeSubtitle()">‚ùå ÿ≠ÿ∞ŸÅ</button>
          </div>
        </div>
      </div>

      <div class="subtitle-section" id="subtitleSection">
        <div class="subtitle-header" onclick="toggleSubtitlePanel()">
          <span class="icon">üí¨</span>
          <span class="title">ÿ≤€åÿ±ŸÜŸà€åÿ≥</span>
          <span class="toggle" id="subToggle">‚ñº ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ</span>
        </div>
        <div class="subtitle-content" id="subtitleContent">
          <div class="sub-search-row">
            <input type="text" id="imdbInput" placeholder="IMDB ID (ÿÆŸàÿØ⁄©ÿßÿ± Ÿæÿ± ŸÖ€åÿ¥Ÿá)" style="display:none;" />
            <button class="btn" id="searchSubBtn" style="width:100%;">üîç ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ÿ≤€åÿ±ŸÜŸà€åÿ≥</button>
          </div>
          <div class="sub-search-row" style="margin-top:10px; direction:ltr;">
            <input type="text" id="srtUrlInput" placeholder="Paste SRT URL here..." style="flex:1; text-align:left;" />
            <button class="btn" id="loadSrtBtn" style="width:auto; padding:12px 15px;">üì• Load</button>
          </div>
          <div id="subStatus" class="sub-status"></div>
          <div id="langContainer"></div>
          <div id="subListContainer"></div>
          <div id="filePickerContainer"></div>
        </div>
      </div>

      <div id="selectionArea"></div>

      <footer class="footer">
        <div class="credit">
          <span>üíú</span>
          <span>ÿ™Ÿàÿ≥ÿ∑</span>
          <span class="credit-name">ÿ¢ŸÇÿß ÿØŸéŸÜ€å</span>
        </div>
      </footer>
    </div>

    <script>
      const $ = id => document.getElementById(id);
      const urlInput = $("url");
      const btn = $("btn");
      const loader = $("loader");
      const player = $("player");
      const video = $("video");
      const statusEl = $("status");
      const selectionArea = $("selectionArea");
      const backToMovie = $("backToMovie");

      let telegramData = null;
      let selectedSubType = null;
      let selectedQuality = null;
      let selectedQualityDetail = null;
      let sourceType = null; // 'telegram' or 'persian'

      // Server management
      let cachedActiveServer = null;
      let lastServerFetch = 0;
      const SERVER_CACHE_TIME = 5 * 60 * 1000; // 5 minutes

      async function getActiveServer() {
        const now = Date.now();
        if (cachedActiveServer && (now - lastServerFetch < SERVER_CACHE_TIME)) {
          return cachedActiveServer;
        }
        
        try {
          const response = await fetch('/active-server');
          const data = await response.json();
          cachedActiveServer = data.activeServer;
          lastServerFetch = now;
          return cachedActiveServer;
        } catch (error) {
          // Don't use p1 as fallback, return null if no server is working
          return null;
        }
      }

      function updateLinksWithActiveServer(downloads) {
        if (!cachedActiveServer) {
          // If no active server, remove external links entirely
          return downloads.filter(dl => !dl.url || !dl.url.includes('external-server.tv'));
        }
        
        return downloads.map(dl => {
          if (dl.url && dl.url.includes('external-server.tv')) {
            // Replace any existing external server with active one
            dl.url = dl.url.replace(/https:\/\/ant\.out\.p\d+\.external-server\.tv\//, cachedActiveServer);
          }
          return dl;
        });
      }

      const setStatus = (msg, type) => {
        statusEl.textContent = msg;
        statusEl.className = "status " + type;
      };

      function play(link) {
        if (!link) return setStatus("ŸÑ€åŸÜ⁄© ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ", "error");
        btn.disabled = true;
        loader.classList.add("show");
        player.classList.remove("show");
        setStatus("ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å...", "loading");

        // Update link with active server if it's an external link
        getActiveServer().then((activeServer) => {
          if (activeServer && link.includes('external-server.tv')) {
            link = link.replace(/https:\/\/ant\.out\.p\d+\.external-server\.tv\//, activeServer);
          } else if (!activeServer && link.includes('external-server.tv')) {
            // No active server available for external links
            loader.classList.remove("show");
            setStatus("‚ùå ÿ≥ÿ±Ÿàÿ± ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™", "error");
            btn.disabled = false;
            return;
          }
          
          video.src = "/stream?url=" + encodeURIComponent(link);
          video.onloadeddata = () => {
            loader.classList.remove("show");
            player.classList.add("show");
            setStatus("ÿ¢ŸÖÿßÿØŸá ŸæÿÆÿ¥ ‚úì", "success");
            btn.disabled = false;
            video.play().catch(() => {});
          };
          video.onerror = () => {
            loader.classList.remove("show");
            setStatus("ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å", "error");
            btn.disabled = false;
          };
        });
      }

      // Simple fullscreen fix - just use container fullscreen on double click
      // Native fullscreen button will work but subtitle won't show (browser limitation)
      // Double click uses container fullscreen which shows subtitle
      video.addEventListener('dblclick', (e) => {
        e.preventDefault();
        toggleContainerFullscreen();
      });
      
      // Custom fullscreen button
      const fullscreenBtn = $('fullscreenBtn');
      let hideTimeout = null;
      
      function showFullscreenBtn() {
        fullscreenBtn.classList.add('visible');
        clearTimeout(hideTimeout);
        if (!video.paused) {
          hideTimeout = setTimeout(() => {
            fullscreenBtn.classList.remove('visible');
          }, 2500);
        }
      }
      
      function updateBtnVisibility() {
        if (video.paused) {
          fullscreenBtn.classList.add('visible');
          clearTimeout(hideTimeout);
        } else {
          hideTimeout = setTimeout(() => {
            fullscreenBtn.classList.remove('visible');
          }, 2500);
        }
      }
      
      video.addEventListener('play', updateBtnVisibility);
      video.addEventListener('pause', updateBtnVisibility);
      video.addEventListener('mousemove', showFullscreenBtn);
      player.addEventListener('mousemove', showFullscreenBtn);
      
      fullscreenBtn.onclick = (e) => {
        e.stopPropagation();
        toggleContainerFullscreen();
      };
      
      function toggleContainerFullscreen() {
        const container = $('player');
        const fs = document.fullscreenElement || document.webkitFullscreenElement;
        if (fs) {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        } else {
          if (container.requestFullscreen) container.requestFullscreen();
          else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
        }
      }
      
      // Update fullscreen button icon
      document.addEventListener('fullscreenchange', updateFullscreenIcon);
      document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
      
      function updateFullscreenIcon() {
        const fs = document.fullscreenElement || document.webkitFullscreenElement;
        fullscreenBtn.textContent = fs ? '‚úï' : '‚õ∂';
        fullscreenBtn.title = fs ? 'ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ™ŸÖÿßŸÖ ÿµŸÅÿ≠Ÿá' : 'ÿ™ŸÖÿßŸÖ ÿµŸÅÿ≠Ÿá (ÿ®ÿß ÿ≤€åÿ±ŸÜŸà€åÿ≥)';
      }
      
      // Draggable subtitle - vertical only
      const subtitleOverlay = $('subtitleOverlay');
      const subtitleText = $('subtitleText');
      let isDragging = false;
      let startY = 0;
      let startBottom = 80;
      
      subtitleText.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.clientY;
        startBottom = parseInt(subtitleOverlay.style.bottom) || 80;
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dy = startY - e.clientY;
        const newBottom = Math.max(20, Math.min(window.innerHeight - 100, startBottom + dy));
        subtitleOverlay.style.bottom = newBottom + 'px';
      });
      
      document.addEventListener('mouseup', () => { isDragging = false; });
      
      // Touch support
      subtitleText.addEventListener('touchstart', (e) => {
        isDragging = true;
        startY = e.touches[0].clientY;
        startBottom = parseInt(subtitleOverlay.style.bottom) || 80;
      }, {passive: true});
      
      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const dy = startY - e.touches[0].clientY;
        const newBottom = Math.max(20, Math.min(window.innerHeight - 100, startBottom + dy));
        subtitleOverlay.style.bottom = newBottom + 'px';
      }, {passive: true});
      
      document.addEventListener('touchend', () => { isDragging = false; });
      
      btn.onclick = () => play(urlInput.value.trim());
      urlInput.onkeypress = e => { if (e.key === "Enter") btn.click(); };

      function groupBySubType(downloads) {
        const groups = {
          dubbed: { label: 'Dubbed', icon: 'üéôÔ∏è', items: [] },
          softsub: { label: 'Soft Subtitle', icon: 'üí¨', items: [] },
          hardsub: { label: 'Hard Subtitle', icon: 'üìù', items: [] },
          other: { label: 'Raw', icon: 'üì¶', items: [] }
        };
        downloads.forEach(dl => {
          if (dl.subType === 'dubbed') groups.dubbed.items.push(dl);
          else if (dl.subType === 'softsub') groups.softsub.items.push(dl);
          else if (dl.subType === 'hardsub') groups.hardsub.items.push(dl);
          else groups.other.items.push(dl);
        });
        return groups;
      }

      function getQualityKey(dl) {
        // Extract quality number (1080, 720, 480, etc.)
        const quality = dl.quality ? `${dl.quality}` : '0';
        return quality;
      }

      function getQualityDetails(dl) {
        // Extract additional details from URL, codec, source, or text
        let details = [];
        
        // Check URL for quality indicators
        const url = (dl.url || '').toLowerCase();
        const text = (dl.text || '').toLowerCase();
        const combined = `${url} ${text}`.toLowerCase();
        
        // Quality indicators to look for
        const qualityIndicators = [
          'web-dl', 'webdl', 'web.dl',
          'hdts', 'hd-ts', 'hd.ts',
          'hdcam', 'hd-cam', 'hd.cam',
          'brrip', 'br-rip', 'br.rip',
          'bluray', 'blu-ray', 'blu.ray',
          'dvdrip', 'dvd-rip', 'dvd.rip',
          'webrip', 'web-rip', 'web.rip',
          'hdtv', 'hd-tv', 'hd.tv',
          'x264', 'x265', 'h264', 'h265',
          'hevc', 'avc'
        ];
        
        // Find quality indicators in URL or text
        for (const indicator of qualityIndicators) {
          if (combined.includes(indicator)) {
            // Format the indicator nicely
            let formatted = indicator.toUpperCase();
            if (formatted.includes('.')) formatted = formatted.replace(/\./g, '-');
            if (!details.includes(formatted)) {
              details.push(formatted);
            }
          }
        }
        
        // Also check codec and source properties if available
        if (dl.codec) {
          const codec = dl.codec.toUpperCase();
          if (!details.includes(codec)) details.push(codec);
        }
        if (dl.source) {
          const source = dl.source.toUpperCase();
          if (!details.includes(source)) details.push(source);
        }
        
        // Return details or "Standard" if none found
        return details.length > 0 ? details.join(' - ') : 'Standard';
      }

      function groupByQuality(items) {
        const groups = {};
        items.forEach(dl => {
          const key = getQualityKey(dl);
          if (!groups[key]) groups[key] = [];
          groups[key].push(dl);
        });
        return Object.fromEntries(
          Object.entries(groups).sort((a, b) => {
            const qa = parseInt(a[0]) || 0;
            const qb = parseInt(b[0]) || 0;
            return qb - qa; // Descending order (1080 -> 720 -> 480)
          })
        );
      }

      function groupByQualityDetails(items) {
        // Group by quality + details for the final step
        const groups = {};
        
        items.forEach(dl => {
          const quality = getQualityKey(dl);
          const details = getQualityDetails(dl);
          const key = `${quality}p ${details}`;
          
          if (!groups[key]) groups[key] = [];
          groups[key].push(dl);
        });
        
        // Sort by quality details - Standard first, then alphabetically
        const sorted = {};
        Object.keys(groups)
          .sort((a, b) => {
            if (a.includes('Standard') && !b.includes('Standard')) return -1;
            if (!a.includes('Standard') && b.includes('Standard')) return 1;
            return a.localeCompare(b);
          })
          .forEach(k => sorted[k] = groups[k]);
        
        return sorted;
      }

      function formatSize(bytes) {
        if (!bytes) return "";
        const gb = bytes / (1024 * 1024 * 1024);
        if (gb >= 1) return `${gb.toFixed(1)} GB`;
        return `${(bytes / (1024 * 1024)).toFixed(0)} MB`;
      }

      async function playFromFileId(dl) {
        if (!dl || !dl.fileId) return;
        try {
          const res = await fetch(`/api/get-download?fileId=${encodeURIComponent(dl.fileId)}`);
          const data = await res.json();
          if (data.success && data.downloadUrl) {
            let url = data.downloadUrl;
            
            // Update URL with active server if it's an external link
            const activeServer = await getActiveServer();
            if (activeServer && url.includes('external-server.tv')) {
              url = url.replace(/https:\/\/ant\.out\.p\d+\.external-server\.tv\//, activeServer);
            } else if (!activeServer && url.includes('external-server.tv')) {
              // No active server available for external links
              setStatus("‚ùå ÿ≥ÿ±Ÿàÿ± ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™", "error");
              return;
            }
            
            play(url);
          } else {
            setStatus("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÑ€åŸÜ⁄©", "error");
          }
        } catch (e) {
          setStatus("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßÿ™ÿµÿßŸÑ", "error");
        }
      }

      function renderSelection() {
        console.log('=== renderSelection called ===');
        console.log('telegramData:', telegramData);
        console.log('selectionArea:', selectionArea);
        
        if (!telegramData || !telegramData.downloads) {
          console.log('No telegramData or downloads, clearing selection area');
          selectionArea.innerHTML = '<div style="padding: 20px; text-align: center; color: #fff;">No data available. Please select a movie from telegram.html first.</div>';
          return;
        }

        console.log('telegramData.downloads:', telegramData.downloads);
        const downloads = telegramData.downloads;
        const isSeries = telegramData.type === "series" || downloads.some(d => d.episode);
        const subTypeGroups = groupBySubType(downloads);
        console.log('subTypeGroups:', subTypeGroups);

        let html = '<div class="selection-area">';

        if (!selectedSubType) {
          html += `
            <div class="step-header">
              <span class="step-num">1</span>
              <span class="step-title">Select Type</span>
            </div>
            <div class="type-grid">
          `;
          for (const [key, group] of Object.entries(subTypeGroups)) {
            if (group.items.length === 0) continue;
            const qualityGroups = groupByQuality(group.items);
            const qCount = Object.keys(qualityGroups).length;
            const epCount = new Set(group.items.map(d => d.episode)).size;
            html += `
              <div class="type-card" onclick="selectType('${key}')">
                <span class="icon">${group.icon}</span>
                <div class="info">
                  <div class="label">${group.label}</div>
                  <div class="meta">${qCount} Qualities ‚Ä¢ ${isSeries ? epCount + ' Episodes' : group.items.length + ' Files'}</div>
                </div>
              </div>
            `;
          }
          html += '</div>';
        }

        else if (!selectedQuality) {
          const group = subTypeGroups[selectedSubType];
          const qualityGroups = groupByQuality(group.items);

          html += `
            <div class="current-selection">
              <span class="sel-tag">${group.icon} ${group.label}</span>
            </div>
            <div class="step-header">
              <span class="step-num">2</span>
              <span class="step-title">Select Quality</span>
              <span class="back-link" onclick="goBack('type')">‚Üê Back</span>
            </div>
            <div class="quality-grid">
          `;
          for (const [qKey, items] of Object.entries(qualityGroups)) {
            const epCount = new Set(items.map(d => d.episode)).size;
            const totalSize = items.reduce((s, d) => s + (d.sizeBytes || 0), 0);
            const avgSize = items.length > 0 ? formatSize(totalSize / items.length) : '';
            
            html += `
              <div class="quality-card" onclick="selectQuality('${qKey.replace(/'/g, "\\'")}')">
                <span class="q-name">${qKey}p</span>
                <span class="q-meta">${isSeries ? epCount + ' Episodes' : items.length + ' Files'}</span>
                ${avgSize ? `<span class="q-size">~${avgSize}</span>` : ''}
              </div>
            `;
          }
          html += '</div>';
        }

        else if (!selectedQualityDetail) {
          const group = subTypeGroups[selectedSubType];
          const qualityGroups = groupByQuality(group.items);
          const items = qualityGroups[selectedQuality] || [];
          const detailGroups = groupByQualityDetails(items);

          html += `
            <div class="current-selection">
              <span class="sel-tag">${group.icon} ${group.label}</span>
              <span class="sel-tag">üìÄ ${selectedQuality}p</span>
            </div>
            <div class="step-header">
              <span class="step-num">3</span>
              <span class="step-title">Select Quality Type</span>
              <span class="back-link" onclick="goBack('quality')">‚Üê Back</span>
            </div>
            <div class="quality-grid">
          `;
          for (const [detailKey, detailItems] of Object.entries(detailGroups)) {
            const epCount = new Set(detailItems.map(d => d.episode)).size;
            const totalSize = detailItems.reduce((s, d) => s + (d.sizeBytes || 0), 0);
            const avgSize = detailItems.length > 0 ? formatSize(totalSize / detailItems.length) : '';
            
            html += `
              <div class="quality-card" onclick="selectQualityDetail('${detailKey.replace(/'/g, "\\'")}')">
                <span class="q-name">${detailKey}</span>
                <span class="q-meta">${isSeries ? epCount + ' Episodes' : detailItems.length + ' Files'}</span>
                ${avgSize ? `<span class="q-size">~${avgSize}</span>` : ''}
              </div>
            `;
          }
          html += '</div>';
        }

        else {
          const group = subTypeGroups[selectedSubType];
          const qualityGroups = groupByQuality(group.items);
          const qualityItems = qualityGroups[selectedQuality] || [];
          const detailGroups = groupByQualityDetails(qualityItems);
          const items = detailGroups[selectedQualityDetail] || [];

          html += `
            <div class="current-selection">
              <span class="sel-tag">${group.icon} ${group.label}</span>
              <span class="sel-tag">üìÄ ${selectedQuality}p</span>
              <span class="sel-tag">üéØ ${selectedQualityDetail}</span>
            </div>
            <div class="step-header">
              <span class="step-num">4</span>
              <span class="step-title">${isSeries ? 'Select Episode' : 'Play'}</span>
              <span class="back-link" onclick="goBack('detail')">‚Üê Back</span>
            </div>
            <div class="episode-grid">
          `;

          items.sort((a, b) => (a.episode || 999) - (b.episode || 999));
          items.forEach((dl, idx) => {
            const epLabel = dl.episode ? `E${String(dl.episode).padStart(2, '0')}` : (isSeries ? 'DL' : 'Play');
            html += `
              <div class="ep-card" onclick="playEpisode(${idx})" data-idx="${idx}">
                <span class="ep-num">${epLabel}</span>
                <span class="ep-size">${dl.size || ''}</span>
              </div>
            `;
          });
          html += '</div>';
        }

        html += '</div>';
        console.log('Setting selectionArea.innerHTML to:', html);
        selectionArea.innerHTML = html;
      }

      window.selectType = function(type) {
        selectedSubType = type;
        selectedQuality = null;
        selectedQualityDetail = null;
        renderSelection();
      };

      window.selectQuality = function(quality) {
        selectedQuality = quality;
        selectedQualityDetail = null;
        renderSelection();
      };

      window.selectQualityDetail = function(qualityDetail) {
        selectedQualityDetail = qualityDetail;
        renderSelection();
      };

      window.goBack = function(level) {
        if (level === 'type') {
          selectedSubType = null;
          selectedQuality = null;
          selectedQualityDetail = null;
        } else if (level === 'quality') {
          selectedQuality = null;
          selectedQualityDetail = null;
        } else if (level === 'detail') {
          selectedQualityDetail = null;
        }
        renderSelection();
      };

      window.playEpisode = function(idx) {
        const group = groupBySubType(telegramData.downloads)[selectedSubType];
        const qualityGroups = groupByQuality(group.items);
        const qualityItems = qualityGroups[selectedQuality] || [];
        const detailGroups = groupByQualityDetails(qualityItems);
        const items = detailGroups[selectedQualityDetail] || [];
        items.sort((a, b) => (a.episode || 999) - (b.episode || 999));
        const dl = items[idx];
        if (dl && dl.url) {
          document.querySelectorAll('.ep-card').forEach(c => c.classList.remove('active'));
          document.querySelector(`.ep-card[data-idx="${idx}"]`)?.classList.add('active');
          play(dl.url);
        }
      };

      function initPersianPlayer(streamData) {
        if (!streamData || !Array.isArray(streamData.downloads)) return;
        selectionArea.innerHTML = '';
        
        const sorted = streamData.downloads.slice().sort((a, b) => parseInt(b.quality) - parseInt(a.quality));
        let html = '<div class="selection-area"><div class="step-header"><span class="step-num">üìÄ</span><span class="step-title">Select Quality</span></div><div class="episode-grid">';
        
        sorted.forEach((dl, idx) => {
          const qLabel = dl.quality ? `${dl.quality}p` : "Quality";
          const sizePart = dl.size ? ` ‚Ä¢ ${dl.size}` : "";
          html += `<div class="ep-card" onclick="playPersian(${idx})" data-idx="${idx}"><span class="ep-num">${qLabel}</span><span class="ep-size">${dl.size || ''}</span></div>`;
        });
        
        html += '</div></div>';
        selectionArea.innerHTML = html;
        
        window.playPersian = function(idx) {
          document.querySelectorAll('.ep-card').forEach(c => c.classList.remove('active'));
          document.querySelector(`.ep-card[data-idx="${idx}"]`)?.classList.add('active');
          playFromFileId(sorted[idx]);
        };
        
        if (sorted[0]) {
          document.querySelector('.ep-card[data-idx="0"]')?.classList.add('active');
          playFromFileId(sorted[0]);
        }
      }

      const params = new URLSearchParams(window.location.search);
      const autoUrl = params.get("url");
      const source = params.get("source");
      const imdbId = params.get("imdb");

      let currentSubtitleTrack = null;
      let subtitleDelay = 0;
      let subtitleLanguages = [];
      let currentSubtitles = [];
      let currentCacheKey = null;
      let parsedCues = [];
      let useCustomOverlay = true;

      function toggleSubtitlePanel() {
        const content = $("subtitleContent");
        const toggle = $("subToggle");
        content.classList.toggle("show");
        toggle.textContent = content.classList.contains("show") ? "‚ñ≤ ÿ®ÿ≥ÿ™ŸÜ" : "‚ñº ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ";
      }

      function setSubStatus(msg, type) {
        const el = $("subStatus");
        el.textContent = msg;
        el.className = "sub-status " + type;
      }

      async function searchSubtitles(retryCount = 0) {
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 1500; // 1.5 seconds
        
        let imdb = $("imdbInput").value.trim();
        let season = null;
        let title = null;
        let type = "movie"; // default to movie

        if (!imdb) {
          try {
            const td = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
            const fd = JSON.parse(localStorage.getItem("persian-current-stream") || "{}");
            imdb = td.imdbId || fd.imdbId || "";
            season = td.season || fd.season || null;
            title = td.title || fd.title || null;
            type = td.type || fd.type || "movie";
            if (imdb) $("imdbInput").value = imdb;
            console.log("üì¶ From localStorage - imdb:", imdb, "season:", season, "title:", title, "type:", type);
          } catch (e) { console.error(e); }
        } else {

          try {
            const td = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
            const fd = JSON.parse(localStorage.getItem("persian-current-stream") || "{}");
            season = td.season || fd.season || null;
            title = td.title || fd.title || null;
            type = td.type || fd.type || "movie";
            console.log("üì¶ Season from localStorage:", season, "title:", title, "type:", type);
          } catch (e) { console.error(e); }
        }
        
        if (!imdb) return setSubStatus("‚ùå IMDB ID Ÿæ€åÿØÿß ŸÜÿ¥ÿØ - ÿßÿ®ÿ™ÿØÿß ŸÅ€åŸÑŸÖ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ", "error");

        const isMovie = type === "movie";
        if (isMovie) {
          season = null;
          console.log("üé¨ Movie detected, ignoring season");
        }
        
        const retryText = retryCount > 0 ? ` (ÿ™ŸÑÿßÿ¥ ${retryCount + 1}/${MAX_RETRIES})` : '';
        setSubStatus(`ÿØÿ± ÿ≠ÿßŸÑ ÿ¨ÿ≥ÿ™ÿ¨Ÿà... ${isMovie ? '(ŸÅ€åŸÑŸÖ)' : '(ŸÅÿµŸÑ ' + (season || '?') + ')'}${retryText}`, "loading");
        
        if (retryCount === 0) {
          $("langContainer").innerHTML = "";
          $("subListContainer").innerHTML = "";
          $("filePickerContainer").innerHTML = "";
        }
        
        try {
          let url = `/subtitle/search?imdbId=${encodeURIComponent(imdb)}`;
          if (season) url += `&season=${encodeURIComponent(season)}`;
          if (title) url += `&title=${encodeURIComponent(title)}`;
          console.log("üîç Searching:", url, retryCount > 0 ? `(retry ${retryCount})` : '');
          const res = await fetch(url);
          const data = await res.json();
          
          if (!data.success || !data.languages || data.languages.length === 0) {

            if (retryCount < MAX_RETRIES - 1) {
              console.log(`‚è≥ No results, retrying in ${RETRY_DELAY}ms... (${retryCount + 1}/${MAX_RETRIES})`);
              setSubStatus(`ÿ≤€åÿ±ŸÜŸà€åÿ≥ Ÿæ€åÿØÿß ŸÜÿ¥ÿØÿå ÿ™ŸÑÿßÿ¥ ŸÖÿ¨ÿØÿØ... (${retryCount + 2}/${MAX_RETRIES})`, "loading");
              await new Promise(r => setTimeout(r, RETRY_DELAY));
              return searchSubtitles(retryCount + 1);
            }
            return setSubStatus("ÿ≤€åÿ±ŸÜŸà€åÿ≥€å Ÿæ€åÿØÿß ŸÜÿ¥ÿØ", "error");
          }
          
          subtitleLanguages = data.languages;
          const seasonInfo = data.selectedSeason ? ` (ŸÅÿµŸÑ ${data.selectedSeason})` : '';
          setSubStatus(`${data.languages.length} ÿ≤ÿ®ÿßŸÜ Ÿæ€åÿØÿß ÿ¥ÿØ${seasonInfo}`, "success");
          renderLanguages();
        } catch (e) {

          if (retryCount < MAX_RETRIES - 1) {
            console.log(`‚è≥ Error, retrying in ${RETRY_DELAY}ms... (${retryCount + 1}/${MAX_RETRIES}):`, e.message);
            setSubStatus(`ÿÆÿ∑ÿßÿå ÿ™ŸÑÿßÿ¥ ŸÖÿ¨ÿØÿØ... (${retryCount + 2}/${MAX_RETRIES})`, "loading");
            await new Promise(r => setTimeout(r, RETRY_DELAY));
            return searchSubtitles(retryCount + 1);
          }
          setSubStatus("ÿÆÿ∑ÿß ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà: " + e.message, "error");
        }
      }

      function renderLanguages() {

        const persian = subtitleLanguages.find(l => l.code === "farsi_persian");
        const english = subtitleLanguages.find(l => l.code === "english");
        const others = subtitleLanguages.filter(l => l.code !== "farsi_persian" && l.code !== "english");
        
        let html = '<div class="lang-grid">';
        
        if (persian) {
          const idx = subtitleLanguages.indexOf(persian);
          html += `<button class="lang-btn" onclick="selectLanguage(${idx})">üáÆüá∑ ŸÅÿßÿ±ÿ≥€å <span class="count">${persian.count}</span></button>`;
        }
        if (english) {
          const idx = subtitleLanguages.indexOf(english);
          html += `<button class="lang-btn" onclick="selectLanguage(${idx})">üá¨üáß English <span class="count">${english.count}</span></button>`;
        }
        if (others.length > 0) {
          html += `<button class="lang-btn" onclick="toggleOtherLangs()">üåç ÿ≥ÿß€åÿ± ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß (${others.length}) ‚ñº</button>`;
        }
        
        html += '</div>';

        if (others.length > 0) {
          html += '<div id="otherLangsPanel" class="lang-grid" style="display:none; margin-top:8px;">';
          others.forEach(lang => {
            const idx = subtitleLanguages.indexOf(lang);
            html += `<button class="lang-btn" onclick="selectLanguage(${idx})">${lang.name} <span class="count">${lang.count}</span></button>`;
          });
          html += '</div>';
        }
        
        $("langContainer").innerHTML = html;

        if (persian) {
          selectLanguage(subtitleLanguages.indexOf(persian));
        }
      }
      
      function toggleOtherLangs() {
        const panel = $("otherLangsPanel");
        if (panel) {
          panel.style.display = panel.style.display === "none" ? "flex" : "none";
        }
      }

      async function selectLanguage(idx) {
        const lang = subtitleLanguages[idx];
        if (!lang) return;

        document.querySelectorAll(".lang-btn").forEach((btn, i) => {
          btn.classList.toggle("active", i === idx);
        });
        
        setSubStatus(`ÿØÿ± ÿ≠ÿßŸÑ ÿØÿ±€åÿßŸÅÿ™ ŸÑ€åÿ≥ÿ™ ${lang.name}...`, "loading");
        $("subListContainer").innerHTML = "";
        $("filePickerContainer").innerHTML = "";
        
        try {
          const res = await fetch(`/subtitle/list?url=${encodeURIComponent(lang.url)}`);
          const data = await res.json();
          
          if (!data.success || !data.subtitles || data.subtitles.length === 0) {
            return setSubStatus("ÿ≤€åÿ±ŸÜŸà€åÿ≥€å ÿØÿ± ÿß€åŸÜ ÿ≤ÿ®ÿßŸÜ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ", "error");
          }
          
          currentSubtitles = data.subtitles;
          setSubStatus(`${data.subtitles.length} ÿ≤€åÿ±ŸÜŸà€åÿ≥ Ÿæ€åÿØÿß ÿ¥ÿØ`, "success");
          renderSubtitleList();
        } catch (e) {
          setSubStatus("ÿÆÿ∑ÿß: " + e.message, "error");
        }
      }

      function renderSubtitleList() {
        let html = '<div class="sub-list">';
        currentSubtitles.forEach((sub, idx) => {
          const ratingClass = sub.rating === "good" ? "good" : "neutral";
          const releasesText = sub.releases.slice(0, 2).join(" ‚Ä¢ ");
          html += `
            <div class="sub-item" onclick="selectSubtitle(${idx})">
              <span class="rating ${ratingClass}"></span>
              <div class="info">
                <div class="releases">${releasesText || "ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ"}</div>
                <div class="meta">
                  <span class="author">üë§ ${sub.author || "ŸÜÿßÿ¥ŸÜÿßÿ≥"}</span>
                  ${sub.comment ? ` ‚Ä¢ ${sub.comment.slice(0, 50)}...` : ""}
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
        $("subListContainer").innerHTML = html;
      }

      async function selectSubtitle(idx) {
        const sub = currentSubtitles[idx];
        if (!sub || !sub.downloadUrl) return;
        
        setSubStatus("ÿØÿ± ÿ≠ÿßŸÑ ÿØÿ±€åÿßŸÅÿ™ ÿµŸÅÿ≠Ÿá ÿØÿßŸÜŸÑŸàÿØ...", "loading");
        
        try {

          const pageRes = await fetch(`/subtitle/download-page?url=${encodeURIComponent(sub.downloadUrl)}`);
          const pageData = await pageRes.json();
          
          if (!pageData.success || !pageData.downloadLink) {
            return setSubStatus("ŸÑ€åŸÜ⁄© ÿØÿßŸÜŸÑŸàÿØ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ", "error");
          }
          
          setSubStatus("ÿØÿ± ÿ≠ÿßŸÑ ÿØÿßŸÜŸÑŸàÿØ Ÿà ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨...", "loading");

          const extractRes = await fetch(`/subtitle/extract?url=${encodeURIComponent(pageData.downloadLink)}`);
          const extractData = await extractRes.json();
          
          if (!extractData.success || !extractData.files || extractData.files.length === 0) {
            return setSubStatus("ŸÅÿß€åŸÑ ÿ≤€åÿ±ŸÜŸà€åÿ≥ ÿØÿ± ÿ¢ÿ±ÿ¥€åŸà Ÿæ€åÿØÿß ŸÜÿ¥ÿØ", "error");
          }
          
          currentCacheKey = extractData.cacheKey;
          setSubStatus(`${extractData.files.length} ŸÅÿß€åŸÑ ÿ≤€åÿ±ŸÜŸà€åÿ≥ Ÿæ€åÿØÿß ÿ¥ÿØ`, "success");
          renderFilePicker(extractData.files);
        } catch (e) {
          setSubStatus("ÿÆÿ∑ÿß: " + e.message, "error");
        }
      }

      function renderFilePicker(files) {
        let html = '<div class="file-picker"><div class="file-picker-title">üìÅ ÿßŸÜÿ™ÿÆÿßÿ® ŸÅÿß€åŸÑ ÿ≤€åÿ±ŸÜŸà€åÿ≥:</div>';
        files.forEach((file, idx) => {
          const sizeMB = (file.size / 1024).toFixed(1);
          html += `<button class="file-btn" onclick="loadSubtitleFile(${file.index}, this)">
            ${file.name} <span style="color:var(--muted)">(${sizeMB} KB)</span>
          </button>`;
        });
        html += '</div>';
        $("filePickerContainer").innerHTML = html;
      }

      async function loadSubtitleFile(index, btn) {
        if (!currentCacheKey) return setSubStatus("ÿÆÿ∑ÿß: ⁄©ÿ¥ ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá", "error");
        
        setSubStatus("ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ≤€åÿ±ŸÜŸà€åÿ≥...", "loading");

        document.querySelectorAll(".file-btn").forEach(b => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
        
        try {
          const url = `/subtitle/file?cacheKey=${encodeURIComponent(currentCacheKey)}&index=${index}`;

          removeSubtitle();

          const res = await fetch(url);
          const vttText = await res.text();
          parsedCues = parseVTT(vttText);
          
          if (parsedCues.length === 0) {
            return setSubStatus("ÿÆÿ∑ÿß: ÿ≤€åÿ±ŸÜŸà€åÿ≥ ÿÆÿßŸÑ€å ÿßÿ≥ÿ™", "error");
          }

          video.addEventListener("timeupdate", renderSubtitleOverlay);
          video.addEventListener("seeking", renderSubtitleOverlay);
          
          setSubStatus(`‚úì ÿ≤€åÿ±ŸÜŸà€åÿ≥ ŸÅÿπÿßŸÑ ÿ¥ÿØ (${parsedCues.length} ÿÆÿ∑)`, "success");
          $("subSettingsBar").style.display = "block"; // Show settings bar

          updateSubStyle();
        } catch (e) {
          setSubStatus("ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å: " + e.message, "error");
        }
      }
      
      function parseVTT(vtt) {
        const cues = [];
        const lines = vtt.split("\n");
        let i = 0;

        while (i < lines.length && !lines[i].includes("-->")) i++;
        
        while (i < lines.length) {
          const line = lines[i].trim();
          if (line.includes("-->")) {
            const [startStr, endStr] = line.split("-->").map(s => s.trim());
            const start = parseTime(startStr);
            const end = parseTime(endStr);

            const textLines = [];
            i++;
            while (i < lines.length && lines[i].trim() !== "" && !lines[i].includes("-->")) {
              textLines.push(lines[i].trim());
              i++;
            }
            
            if (textLines.length > 0) {
              cues.push({ start, end, text: textLines.join("\n") });
            }
          } else {
            i++;
          }
        }
        return cues;
      }
      
      function parseTime(str) {

        const parts = str.split(":");
        if (parts.length === 3) {
          const [h, m, s] = parts;
          return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);
        } else if (parts.length === 2) {
          const [m, s] = parts;
          return parseFloat(m) * 60 + parseFloat(s);
        }
        return 0;
      }
      
      function renderSubtitleOverlay() {
        const time = video.currentTime + subtitleDelay;
        const overlay = $("subtitleText");
        if (!overlay) return;

        const cue = parsedCues.find(c => time >= c.start && time <= c.end);
        
        if (cue) {

          let text = cue.text.replace(/<[^>]+>/g, "");
          overlay.innerHTML = text;
        } else {
          overlay.innerHTML = "";
        }
      }

      function removeSubtitle() {

        video.removeEventListener("timeupdate", renderSubtitleOverlay);
        video.removeEventListener("seeking", renderSubtitleOverlay);

        parsedCues = [];

        const overlay = $("subtitleText");
        if (overlay) overlay.innerHTML = "";

        if (currentSubtitleTrack) {
          currentSubtitleTrack.remove();
          currentSubtitleTrack = null;
        }
        const tracks = video.querySelectorAll("track");
        tracks.forEach(t => t.remove());
        
        $("subSettingsBar").style.display = "none";
        setSubStatus("ÿ≤€åÿ±ŸÜŸà€åÿ≥ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ", "success");
      }

      function toggleSettings() {
        const settings = $("subSettings");
        settings.style.display = settings.style.display === "none" ? "flex" : "none";
      }

      function hexToRgba(hex, opacity) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${opacity / 100})`;
      }

      function updateSubStyle() {
        const size = $("subSize").value;
        const color = $("subColor").value;
        const bgColor = $("subBgColor")?.value || "#000000";
        const bgOpacity = $("subBgOpacity")?.value || 85;
        const bg = hexToRgba(bgColor, bgOpacity);
        const font = $("subFont")?.value || '"ShabnamLightFD", Tahoma';
        const position = $("subPosition")?.value || 60;
        
        $("subSizeVal").textContent = size + "px";
        if ($("subBgOpacityVal")) $("subBgOpacityVal").textContent = bgOpacity + "%";
        if ($("subPosVal")) $("subPosVal").textContent = position + "px";

        const overlay = $("subtitleText");
        const overlayContainer = $("subtitleOverlay");
        if (overlay) {
          overlay.style.fontSize = size + "px";
          overlay.style.color = color;
          overlay.style.backgroundColor = bg;
          overlay.style.fontFamily = font;
          overlay.style.lineHeight = "1.5";
          overlay.style.padding = "10px 20px";
          overlay.style.borderRadius = "8px";
        }
        if (overlayContainer) {
          overlayContainer.style.bottom = position + "px";
        }

        try {
          localStorage.setItem("sub-settings", JSON.stringify({ size, color, bgColor, bgOpacity, font, position }));
        } catch(e) {}
      }
      
      function updateSubPosition() {
        const position = $("subPosition").value;
        $("subPosVal").textContent = position + "px";
        $("subtitleOverlay").style.bottom = position + "px";
        
        try {
          const saved = JSON.parse(localStorage.getItem("sub-settings") || "{}");
          saved.position = position;
          localStorage.setItem("sub-settings", JSON.stringify(saved));
        } catch(e) {}
      }

      function loadSubSettings() {
        try {
          const saved = JSON.parse(localStorage.getItem("sub-settings") || "{}");
          if (saved.size) $("subSize").value = saved.size;
          if (saved.color) $("subColor").value = saved.color;
          if (saved.bgColor && $("subBgColor")) $("subBgColor").value = saved.bgColor;
          if (saved.bgOpacity && $("subBgOpacity")) $("subBgOpacity").value = saved.bgOpacity;
          if (saved.font) $("subFont").value = saved.font;
          if (saved.position && $("subPosition")) $("subPosition").value = saved.position;
          updateSubStyle();
        } catch(e) {}
      }
      loadSubSettings();
      
      function adjustDelay(delta) {
        subtitleDelay += delta;
        const delayEl = $("delayVal");
        if (delayEl) delayEl.textContent = subtitleDelay.toFixed(1) + "s";
        renderSubtitleOverlay();
      }

      $("searchSubBtn").onclick = function() {
        if (sourceType === 'persian') {
          setSubStatus("ÿ®ÿ±ÿß€å ŸÅ€åŸÑŸÖ‚ÄåŸáÿß€å ŸÅÿßÿ±ÿ≥€å ÿ≤€åÿ±ŸÜŸà€åÿ≥ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™", "error");
          return;
        }
        searchSubtitles();
      };
      $("imdbInput").onkeypress = function(e) {
        if (e.key === "Enter") {
          if (sourceType === 'persian') {
            setSubStatus("ÿ®ÿ±ÿß€å ŸÅ€åŸÑŸÖ‚ÄåŸáÿß€å ŸÅÿßÿ±ÿ≥€å ÿ≤€åÿ±ŸÜŸà€åÿ≥ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™", "error");
            return;
          }
          searchSubtitles();
        }
      };
      $("loadSrtBtn").onclick = loadSrtFromUrl;
      $("srtUrlInput").onkeypress = e => { if (e.key === "Enter") loadSrtFromUrl(); };

      async function loadSrtFromUrl() {
        const url = $("srtUrlInput").value.trim();
        if (!url) return setSubStatus("Please enter an SRT URL", "error");
        
        setSubStatus("Loading subtitle from URL...", "loading");
        
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const srtText = await res.text();
          
          if (!srtText || srtText.length < 10) {
            return setSubStatus("Invalid or empty SRT file", "error");
          }

          parsedCues = parseSRT(srtText);
          if (parsedCues.length === 0) {
            return setSubStatus("Could not parse SRT file", "error");
          }
          
          useCustomOverlay = true;
          subtitleDelay = 0;
          showSubSettingsBar();
          setSubStatus(`‚úÖ Loaded ${parsedCues.length} subtitle cues`, "success");

          $("langContainer").innerHTML = "";
          $("subListContainer").innerHTML = "";
          $("filePickerContainer").innerHTML = "";
          
        } catch (e) {
          setSubStatus("Error loading URL: " + e.message, "error");
        }
      }

      if (imdbId && sourceType !== 'persian') {
        // Only search subtitles for non-Persian movies with IMDB ID
        $("imdbInput").value = imdbId;
        toggleSubtitlePanel();
        setTimeout(searchSubtitles, 500);
      } else if (sourceType !== 'persian') {
        // Only auto-search subtitles for non-Persian movies
        try {
          const telegramData = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
          const persianData = JSON.parse(localStorage.getItem("persian-current-stream") || "{}");
          const storedImdb = telegramData.imdbId || persianData.imdbId;
          if (storedImdb) {
            $("imdbInput").value = storedImdb;
            toggleSubtitlePanel();
            setTimeout(searchSubtitles, 500);
          }
        } catch (e) {}
      } else {
        // For Persian movies, ensure no subtitle search happens
        console.log('Persian movie detected - skipping subtitle search');
      }

      if (autoUrl) {
        urlInput.value = decodeURIComponent(autoUrl);
        play(decodeURIComponent(autoUrl));
      } else if (source === "telegram") {
        sourceType = 'telegram';
        try {
          telegramData = JSON.parse(localStorage.getItem("telegram-downloads") || "{}");
          console.log('Loaded telegramData:', telegramData);
          
          // Update downloads with active server
          if (telegramData.downloads) {
            getActiveServer().then(() => {
              if (cachedActiveServer) {
                telegramData.downloads = updateLinksWithActiveServer(telegramData.downloads);
              }
              
              if (telegramData.title) urlInput.placeholder = `ŸæÿÆÿ¥: ${telegramData.title}`;
              backToMovie.style.display = "inline-block";

              if (telegramData.imdbId) {
                backToMovie.href = `/telegram.html?restore=${telegramData.imdbId}`;
              } else {
                backToMovie.href = "/telegram.html";
              }
              console.log('About to call renderSelection');
              renderSelection();
              console.log('renderSelection called');
            });
          }
        } catch (e) {
          console.error('Error loading telegram data:', e);
        }
      } else {
        sourceType = 'persian';
        try {
          const streamData = JSON.parse(localStorage.getItem("persian-current-stream") || "null");
          if (streamData) {
            if (streamData.title) urlInput.placeholder = `ŸæÿÆÿ¥: ${streamData.title}`;
            if (streamData.source) {
              backToMovie.style.display = "inline-block";
              backToMovie.href = streamData.source;
            }
            if (streamData.downloads && streamData.downloads.length) {
              initPersianPlayer(streamData);
            }
            
            // COMPLETELY clear all subtitle cache and prevent any subtitle loading for Persian movies
            clearAllSubtitleData();
            showPersianMovieSubtitleMessage();
            
            // Keep subtitle panel closed for Persian movies
            const subtitleContent = $("subtitleContent");
            const toggle = $("subToggle");
            if (subtitleContent && toggle) {
              subtitleContent.classList.remove("show");
              toggle.textContent = "‚ñº ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ";
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
      
      function clearAllSubtitleData() {
        // Clear ALL subtitle-related localStorage data
        try {
          // Remove all possible subtitle cache keys
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.includes('subtitle') || key.includes('sub-') || key.includes('imdb'))) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));
          
          // Also clear specific known keys
          localStorage.removeItem('telegram-downloads');
          localStorage.removeItem('sub-settings');
        } catch (e) {
          console.error('Error clearing localStorage:', e);
        }
        
        // Clear all subtitle-related variables
        subtitleLanguages = [];
        currentSubtitles = [];
        currentCacheKey = null;
        parsedCues = [];
        subtitleDelay = 0;
        
        // Clear all UI elements
        $("langContainer").innerHTML = "";
        $("subListContainer").innerHTML = "";
        $("filePickerContainer").innerHTML = "";
        
        // Clear inputs
        const imdbInput = $("imdbInput");
        if (imdbInput) imdbInput.value = "";
        
        const srtUrlInput = $("srtUrlInput");
        if (srtUrlInput) srtUrlInput.value = "";
        
        // Remove any active subtitle
        removeSubtitle();
        
        // Clear subtitle status
        setSubStatus("", "");
      }
      
      function showPersianMovieSubtitleMessage() {
        // Hide the search button completely for Persian movies
        const searchBtn = $("searchSubBtn");
        if (searchBtn) {
          searchBtn.style.display = "none";
        }
        
        // Clear all subtitle containers first
        $("langContainer").innerHTML = "";
        $("subListContainer").innerHTML = "";
        $("filePickerContainer").innerHTML = "";
        
        const subtitleContent = $("subtitleContent");
        
        // Remove any existing Persian message
        const existingMessage = document.getElementById('persianSubtitleMessage');
        if (existingMessage) {
          existingMessage.remove();
        }
        
        // Add Persian movie subtitle message
        const persianMessage = document.createElement('div');
        persianMessage.id = 'persianSubtitleMessage';
        persianMessage.style.cssText = `
          background: linear-gradient(135deg, rgba(255,193,7,0.1), rgba(255,152,0,0.1));
          border: 1px solid rgba(255,193,7,0.3);
          border-radius: 10px;
          padding: 15px;
          margin: 10px 0;
          text-align: center;
          color: #ffc107;
        `;
        persianMessage.innerHTML = `
          <div style="font-size: 16px; margin-bottom: 8px;">üé¨ ŸÅ€åŸÑŸÖ ŸÅÿßÿ±ÿ≥€å</div>
          <div style="font-size: 13px; color: #ffecb3; margin-bottom: 10px;">
            ÿ®ÿ±ÿß€å ŸÅ€åŸÑŸÖ‚ÄåŸáÿß€å ŸÅÿßÿ±ÿ≥€å ÿ≤€åÿ±ŸÜŸà€åÿ≥ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™
          </div>
          <div style="font-size: 12px; color: #fff3c4;">
            üí° ÿß⁄Øÿ± ÿ≤€åÿ±ŸÜŸà€åÿ≥ ÿØÿßÿ±€åÿØÿå ŸÖ€å‚Äåÿ™ŸàŸÜ€åÿØ ŸÑ€åŸÜ⁄© ŸÅÿß€åŸÑ SRT ÿ±Ÿà ÿØÿ± ŸÇÿ≥ŸÖÿ™ Ÿæÿß€å€åŸÜ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ
          </div>
        `;
        
        // Insert the message at the beginning of subtitle content
        const firstChild = subtitleContent.firstChild;
        subtitleContent.insertBefore(persianMessage, firstChild);
        
        // Update the subtitle status
        setSubStatus("ŸÅ€åŸÑŸÖ ŸÅÿßÿ±ÿ≥€å - ÿ≤€åÿ±ŸÜŸà€åÿ≥ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™", "error");
      }
    </script>
  </body>
</html>
